---
title: Filtering
description: Filter queries with FastGQL
---


import {TabItem, Tabs} from '@astrojs/starlight/components';

# Filtering

FastGQL extends the GraphQL schema adding `filter` input for objects and adding `filter` arguments to the queries and mutations. We can use the `filter` argument in our queries to filter results based on the field's values. FastGQL allows to add multiple filters with `AND`, `OR`, `NOT` and even nested object filters.

## Simple Operators

fetch posts with where `id == 3`

```graphql
query {
  posts(limit: 3, filter: { id: { eq: 3 } }) {
    id
  }
}
```

## Logical filters

#### AND filter

By default, a logical `AND` operation is preformed on all the conditions mentioned in the filter clause. If we want to use the same field key, than we need to use the `AND` operator in the GraphQL query.

<Tabs>
    <TabItem label="Single">
        ```graphql
        query {
            # expected filter: name = "article 1" AND id = 1
            posts(filter: {name: {eq: "article 1"}, id: {eq: 1}}) {
                id
                name
            }
        }
        ```
    </TabItem>
    <TabItem label="Multiple">
        ```graphql
        query {
            # expected filter: name = "article 1" AND name like "%article%" AND id = 1
            posts(filter: { AND: [ {name: {eq: "article 1"}}, {name: {like: "%article%"}}, {id: {eq: 1}}]}) {
                id
                name
            }
        }
        ```
    </TabItem>
</Tabs>

#### OR filter

To perform a logical `OR` operation, we have to use the `OR` operator in the GraphQL query.&#x20;

If we would like to fetch information of all post's name that start with the prefix `a` or `b` the following query will return the desired result:

```graphql
query {
    posts(
        filter: { OR: [{ name: { prefix: "a" } }, { name: { suffix: "b" } }] }
    ) {
        id
        name
    }
}
```

#### NOT filter

To perform a logical `NOT`operation, we have to use the `NOT`operator in the GraphQL query.&#x20;

if we would like  to fetch information of all post's name that **don't** start with "a" or ends with "b". the following query will return the desired result:

```graphql
query {
    posts(
        filter: {
            NOT: { OR: [{ name: { prefix: "a" } }, { name: { suffix: "b" } }] }
        }
    ) {
        id
        name
    }
}
```

#### Nested filters

We can also perform complex nested logical operation, such as `OR` inside an `AND` operator. The following query will result the following filter:

```sql
(name like 'b%' OR name like 'a%') AND name like '%c%'
```

```graphql
query {
    posts(
        filter: {
            AND: [
                { OR: [{ name: { prefix: "a" } }, { name: { suffix: "b" } }] }
                { name: { like: "%c%" } }
            ]
        }
    ) {
        id
        name
    }
}
```

## Object Filters

Most objects in our schema usually have fields that aren't `scalars`, and we would like to filter by thier fields. In our example each post has one or more categories we would want to filter posts by some category name. The following GraphQL query will filter for us those posts that have a category name called "Security"

```graphql
query ObjectFilterExample {
    posts(filter: {categories: {name: {eq: "Security"}}}) {
        id
        name
    }
}
```

## JSON Filtering

FastGQL provides powerful filtering capabilities for PostgreSQL JSONB columns, allowing you to query structured and dynamic JSON data stored in your database. There are two approaches for working with JSON data, each suited to different use cases.

:::note[Filtering vs. Field Selection]
**Filtering** determines WHICH rows to return based on JSON content (this section).

**Field Selection** determines WHICH fields to extract from JSON in the response. See [JSON Field Selection](queries.md#json-field-selection) for details on selecting specific nested fields from typed JSON columns.

Both features can be used together - filter which rows to return, then select specific fields from the JSON data in those rows.
:::

### Typed JSON Filtering (Recommended)

For JSON data with a known, consistent structure, use the `@json` directive with a GraphQL object type. This provides type-safe filtering with full IDE support and validation.

#### Schema Setup

First, define the structure of your JSON data as a GraphQL type:

```graphql
type ProductAttributes {
    color: String
    size: Int
    weight: Float
    tags: [String]
}

type Product @generateFilterInput @table(name: "products") {
    id: Int!
    name: String!
    # Typed JSON field stored in JSONB column
    attributes: ProductAttributes @json(column: "attributes")
}

type Query {
    products: [Product] @generate
}
```

FastGQL automatically generates a `ProductAttributesFilterInput` with all the standard filter operators.

#### Simple Field Filtering

Filter by a single field in the JSON object:

```graphql
query {
    # Find products with red color
    products(filter: { attributes: { color: { eq: "red" } } }) {
        name
        attributes
    }
}
```

#### Multiple Field Filtering

Filter by multiple fields (implicit AND):

```graphql
query {
    # Find blue products larger than size 15
    products(filter: {
        attributes: {
            color: { eq: "blue" },
            size: { gt: 15 }
        }
    }) {
        name
        attributes
    }
}
```

#### Logical Operators in JSON Filters

Use AND, OR, and NOT operators within JSON filters:

<Tabs>
    <TabItem label="AND">
        ```graphql
        query {
            # Red products with size greater than 12
            products(filter: {
                attributes: {
                    AND: [
                        { color: { eq: "red" } },
                        { size: { gt: 12 } }
                    ]
                }
            }) {
                name
            }
        }
        ```
    </TabItem>
    <TabItem label="OR">
        ```graphql
        query {
            # Green products OR small products (size < 10)
            products(filter: {
                attributes: {
                    OR: [
                        { color: { eq: "green" } },
                        { size: { lt: 10 } }
                    ]
                }
            }) {
                name
            }
        }
        ```
    </TabItem>
    <TabItem label="NOT">
        ```graphql
        query {
            # Products that are NOT blue
            products(filter: {
                attributes: {
                    NOT: { color: { eq: "blue" } }
                }
            }) {
                name
            }
        }
        ```
    </TabItem>
</Tabs>

#### Nested Object Filtering

For JSON with nested objects, define the nested structure and filter through it:

```graphql
type ProductDetails {
    manufacturer: String
    model: String
    year: Int
}

type ProductAttributes {
    color: String
    size: Int
    # Nested object in JSON
    details: ProductDetails
}

type Product @generateFilterInput @table(name: "products") {
    id: Int!
    name: String!
    attributes: ProductAttributes @json(column: "attributes")
}
```

Query with nested filters:

```graphql
query {
    # Filter by nested manufacturer field
    products(filter: {
        attributes: {
            details: {
                manufacturer: { eq: "Acme" }
            }
        }
    }) {
        name
        attributes
    }
}
```

You can also combine nested and top-level filters:

```graphql
query {
    # Red products from Acme
    products(filter: {
        attributes: {
            color: { eq: "red" },
            details: {
                manufacturer: { eq: "Acme" },
                year: { gte: 2020 }
            }
        }
    }) {
        name
    }
}
```

### Map Scalar Filtering (Dynamic JSON)

For JSON data with a variable or unknown structure, use the `Map` scalar type. This provides runtime filtering using JSONPath expressions.

#### Schema Setup

```graphql
type Product @generateFilterInput @table(name: "products") {
    id: Int!
    name: String!
    # Dynamic JSON field
    metadata: Map
}

type Query {
    products: [Product] @generate
}
```

#### Contains Operator

Use `contains` to check if the JSON contains specific key-value pairs (PostgreSQL `@>` operator):

```graphql
query {
    # Products with discount flag
    products(filter: {
        metadata: {
            contains: { discount: "true" }
        }
    }) {
        name
    }
}
```

For nested containment:

```graphql
query {
    # Products with nested shipping info
    products(filter: {
        metadata: {
            contains: {
                shipping: {
                    method: "express"
                }
            }
        }
    }) {
        name
    }
}
```

#### JSONPath Filtering with `where`

Use `where` for conditions on specific JSON paths (combined with AND logic):

```graphql
query {
    # Products with price less than 100 AND discount enabled
    products(filter: {
        metadata: {
            where: [
                { path: "price", lt: 100 },
                { path: "discount", eq: "true" }
            ]
        }
    }) {
        name
    }
}
```

#### JSONPath Filtering with `whereAny`

Use `whereAny` for OR conditions:

```graphql
query {
    # Products with high rating OR discount
    products(filter: {
        metadata: {
            whereAny: [
                { path: "rating", gt: 4 },
                { path: "discount", eq: "true" }
            ]
        }
    }) {
        name
    }
}
```

#### Complex JSONPath Expressions

Filter on nested fields and array elements:

<Tabs>
    <TabItem label="Nested Fields">
        ```graphql
        query {
            # Filter by nested field path
            products(filter: {
                metadata: {
                    where: [
                        { path: "shipping.cost", lt: 10 }
                    ]
                }
            }) {
                name
            }
        }
        ```
    </TabItem>
    <TabItem label="Array Index">
        ```graphql
        query {
            # Filter by first item in array
            products(filter: {
                metadata: {
                    where: [
                        { path: "items[0].name", eq: "widget" }
                    ]
                }
            }) {
                name
            }
        }
        ```
    </TabItem>
    <TabItem label="Null Checks">
        ```graphql
        query {
            # Products where expiry field is not null
            products(filter: {
                metadata: {
                    where: [
                        { path: "expiry", isNull: false }
                    ]
                }
            }) {
                name
            }
        }
        ```
    </TabItem>
</Tabs>

#### Combining Map Operators

You can combine multiple Map operators (they're combined with AND logic):

```graphql
query {
    # Products with discount AND price less than 75
    products(filter: {
        metadata: {
            contains: { discount: "true" },
            where: [{ path: "price", lt: 75 }]
        }
    }) {
        name
    }
}
```

#### Available Operators in MapPathCondition

When using `where` or `whereAny`, each condition supports these operators:

- `eq`: String equality
- `neq`: String inequality
- `gt`, `gte`, `lt`, `lte`: Numeric comparisons
- `like`: Regex pattern matching
- `isNull`: Check for null values

Example using multiple operator types:

```graphql
query {
    products(filter: {
        metadata: {
            where: [
                { path: "name", like: "^Pro.*" },
                { path: "price", gte: 50 },
                { path: "discount", eq: "true" },
                { path: "discontinued", isNull: true }
            ]
        }
    }) {
        name
    }
}
```

### Choosing Between Typed JSON and Map

**Use Typed JSON (`@json` directive) when:**
- Your JSON structure is known and consistent across records
- You want compile-time type safety and GraphQL validation
- You need IDE auto-completion and schema introspection
- Your JSON represents well-defined domain objects

**Use Map scalar when:**
- Your JSON structure varies between records
- You need maximum runtime flexibility
- You're storing user-defined or external system data
- Your JSON is truly dynamic metadata or configuration

**Example combining both:**

```graphql
type Product @generateFilterInput @table(name: "products") {
    id: Int!
    name: String!
    # Known structure - use typed JSON
    attributes: ProductAttributes @json(column: "attributes")
    # Variable structure - use Map
    metadata: Map
}
```

This allows you to have type-safe filtering for known fields while maintaining flexibility for dynamic data.

### Combining Filtering and Field Selection

You can combine JSON filtering (to determine which rows to return) with field selection (to extract specific fields) in the same query:

```graphql
query {
    # Filter: Return only products where attributes.color == "red"
    # Selection: Extract only the manufacturer from the nested details
    products(filter: { attributes: { color: { eq: "red" } } }) {
        name
        attributes {
            color
            details {
                manufacturer
            }
        }
    }
}
```

This query:
1. Filters products to only include those with red color (database WHERE clause)
2. For matching products, extracts only the `color` field and `manufacturer` from nested `details`
3. Does not extract other fields like `size`, `model`, `warranty`, etc.

Both operations are performed efficiently at the database level using PostgreSQL's native JSONB operators.
