---
title: Filtering
description: Filter queries with FastGQL
---


import {TabItem, Tabs} from '@astrojs/starlight/components';

# Filtering

FastGQL extends the GraphQL schema adding `filter` input for objects and adding `filter` arguments to the queries and mutations. We can use the `filter` argument in our queries to filter results based on the field's values. FastGQL allows to add multiple filters with `AND`, `OR`, `NOT` and even nested object filters.

## Simple Operators

fetch posts with where `id == 3`

```graphql
query {
  posts(limit: 3, filter: { id: { eq: 3 } }) {
    id
  }
}
```

## Logical filters

#### AND filter

By default, a logical `AND` operation is preformed on all the conditions mentioned in the filter clause. If we want to use the same field key, than we need to use the `AND` operator in the GraphQL query.

<Tabs>
    <TabItem label="Single">
        ```graphql
        query {
            # expected filter: name = "article 1" AND id = 1
            posts(filter: {name: {eq: "article 1"}, id: {eq: 1}}) {
                id
                name
            }
        }
        ```
    </TabItem>
    <TabItem label="Multiple">
        ```graphql
        query {
            # expected filter: name = "article 1" AND name like "%article%" AND id = 1
            posts(filter: { AND: [ {name: {eq: "article 1"}}, {name: {like: "%article%"}}, {id: {eq: 1}}]}) {
                id
                name
            }
        }
        ```
    </TabItem>
</Tabs>

#### OR filter

To perform a logical `OR` operation, we have to use the `OR` operator in the GraphQL query.&#x20;

If we would like to fetch information of all post's name that start with the prefix `a` or `b` the following query will return the desired result:

```graphql
query {
    posts(
        filter: { OR: [{ name: { prefix: "a" } }, { name: { suffix: "b" } }] }
    ) {
        id
        name
    }
}
```

#### NOT filter

To perform a logical `NOT`operation, we have to use the `NOT`operator in the GraphQL query.&#x20;

if we would like  to fetch information of all post's name that **don't** start with "a" or ends with "b". the following query will return the desired result:

```graphql
query {
    posts(
        filter: {
            NOT: { OR: [{ name: { prefix: "a" } }, { name: { suffix: "b" } }] }
        }
    ) {
        id
        name
    }
}
```

#### Nested filters

We can also perform complex nested logical operation, such as `OR` inside an `AND` operator. The following query will result the following filter:

```sql
(name like 'b%' OR name like 'a%') AND name like '%c%'
```

```graphql
query {
    posts(
        filter: {
            AND: [
                { OR: [{ name: { prefix: "a" } }, { name: { suffix: "b" } }] }
                { name: { like: "%c%" } }
            ]
        }
    ) {
        id
        name
    }
}
```

## Object Filters

Most objects in our schema usually have fields that aren't `scalars`, and we would like to filter by thier fields. In our example each post has one or more categories we would want to filter posts by some category name. The following GraphQL query will filter for us those posts that have a category name called "Security"

```graphql
query ObjectFilterExample {
    posts(filter: {categories: {name: {eq: "Security"}}}) {
        id
        name
    }
}
```

## JSON Filtering

FastGQL supports filtering PostgreSQL JSONB columns using two approaches: typed JSON for known structures, and Map scalar for dynamic data.

:::note[Filtering vs. Field Selection]
**Filtering** determines which rows to return based on JSON content. **Field Selection** determines which fields to extract from JSON in the response (see [JSON Field Selection](queries#json-field-selection)). Both can be used together.
:::

### Typed JSON Filtering (Recommended)

Use the `@json` directive with a GraphQL object type for structured JSON with type-safe filtering:

```graphql
type ProductAttributes {
    color: String
    size: Int
    details: ProductDetails
}

type ProductDetails {
    manufacturer: String
    year: Int
}

type Product @generateFilterInput @table(name: "products") {
    id: Int!
    name: String!
    attributes: ProductAttributes @json(column: "attributes")
}
```

**Simple filtering:**
```graphql
query {
    products(filter: { attributes: { color: { eq: "red" } } }) {
        name
    }
}
```

**Multiple fields (implicit AND):**
```graphql
query {
    products(filter: {
        attributes: {
            color: { eq: "blue" },
            size: { gt: 15 }
        }
    }) {
        name
    }
}
```

**Logical operators:**

<Tabs>
    <TabItem label="OR">
        ```graphql
        products(filter: {
            attributes: {
                OR: [
                    { color: { eq: "green" } },
                    { size: { lt: 10 } }
                ]
            }
        })
        ```
    </TabItem>
    <TabItem label="NOT">
        ```graphql
        products(filter: {
            attributes: {
                NOT: { color: { eq: "blue" } }
            }
        })
        ```
    </TabItem>
</Tabs>

**Nested objects:**
```graphql
query {
    products(filter: {
        attributes: {
            color: { eq: "red" },
            details: {
                manufacturer: { eq: "Acme" },
                year: { gte: 2020 }
            }
        }
    }) {
        name
    }
}
```

### Map Scalar Filtering (Dynamic JSON)

Use the `Map` scalar type for JSON with variable structure. Filtering uses runtime JSONPath expressions.

```graphql
type Product @generateFilterInput {
    id: Int!
    metadata: Map
}
```

**Contains operator** (PostgreSQL `@>`):
```graphql
products(filter: {
    metadata: { contains: { discount: "true" } }
})
```

**JSONPath with `where` (AND logic):**
```graphql
products(filter: {
    metadata: {
        where: [
            { path: "price", lt: 100 },
            { path: "discount", eq: "true" }
        ]
    }
})
```

**JSONPath with `whereAny` (OR logic):**
```graphql
products(filter: {
    metadata: {
        whereAny: [
            { path: "rating", gt: 4 },
            { path: "discount", eq: "true" }
        ]
    }
})
```

**Complex paths:**

<Tabs>
    <TabItem label="Nested">
        ```graphql
        where: [{ path: "shipping.cost", lt: 10 }]
        ```
    </TabItem>
    <TabItem label="Array">
        ```graphql
        where: [{ path: "items[0].name", eq: "widget" }]
        ```
    </TabItem>
</Tabs>

**Available operators in MapPathCondition:** `eq`, `neq`, `gt`, `gte`, `lt`, `lte`, `like`, `isNull`

See [MapComparator](../schema/operators#mapcomparator) for operator details.

### Choosing Between Typed JSON and Map

- **Typed JSON**: Known structure, type safety, IDE auto-completion
- **Map scalar**: Variable structure, runtime flexibility, arbitrary metadata

You can use both in the same type for different fields.

For a complete example, see [examples/json](https://github.com/roneli/fastgql/tree/master/examples/json).
