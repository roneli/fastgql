# Update

## Auto-generated insert mutation

FastGQL auto generates `update<OBJECT_NAME>` update mutations if the [#generatemutations](../schema/directives.md#generatemutations "mention")is set. The following code will be added to the GraphQL schema.

```graphql

mutation {
	# updatePosts allows to update posts with a filter
	updatePosts(input: UpdatePostInput!, filter: PostFilterInput): PostsPayload
	# ... more mutations
}

"""
Autogenerated Posts Filter Input
"""
input PostFilterInput {
	id: IntComparator
	name: StringComparator
	categories: CategoryFilterInput
	user: UserFilterInput
	"""
	Logical AND of FilterInput
	"""
	AND: [PostFilterInput]
	"""
	Logical OR of FilterInput
	"""
	OR: [PostFilterInput]
	"""
	Logical NOT of FilterInput
	"""
	NOT: PostFilterInput
}

"""
AutoGenerated update input for Post
"""
input UpdatePostInput {
	id: Int
	name: String
}

"""
Autogenerated payload object
"""
type PostsPayload {
	"""
	rows affection by mutation
	"""
	rows_affected: Int!
	posts: [Post]
}
```

The [#generatemutations](../schema/directives.md#generatemutations "mention") directive adds the above into our schema.

* `inputs` argument passed to `createPosts` mutation is required and you can pass 1 or more objects.
* `PostsPayload` is the response object returned from the mutation, returning the amounts of rows\_affected i.e. the amount of objects inserted and access to all our posts info

## Update Objects

**Example:** update posts and return the updated posts object in the response:

{% tabs %}
{% tab title="Update with filter" %}
{% code overflow="wrap" %}
```graphql
mutation { 
    updatePosts(input: {name: "newPost"}, filter: {id: {eq: 1}}) {
        rows_affected 
        posts { 
        name 
        id 
        } 
    } 
}
```
{% endcode %}
{% endtab %}
{% endtabs %}
