# Delete

## Auto-generated delete mutation

FastGQL auto generates `delete<OBJECT_NAME>` delete mutations if the [#generatemutations](../schema/directives.md#generatemutations "mention")is set. The following code will be added to the GraphQL schema.

```graphql

mutation {
	# createPosts allows to insert one or more Posts
	deletePosts(cascade: Boolean, filter: PostFilterInput): PostsPayload
	# ... more mutations
}

"""
Autogenerated Posts Filter Input
"""
input PostFilterInput {
	id: IntComparator
	name: StringComparator
	categories: CategoryFilterInput
	user: UserFilterInput
	"""
	Logical AND of FilterInput
	"""
	AND: [PostFilterInput]
	"""
	Logical OR of FilterInput
	"""
	OR: [PostFilterInput]
	"""
	Logical NOT of FilterInput
	"""
	NOT: PostFilterInput
}

"""
Autogenerated payload object
"""
type PostsPayload {
	"""
	rows affection by mutation
	"""
	rows_affected: Int!
	posts: [Post]
}
```

The [#generatemutations](../schema/directives.md#generatemutations "mention") directive adds the above into our schema.

* **filter** argument passed to `deletePosts`mutation allows to filter what posts we want to delete.
* The **cascade** argument defines if we want to cascade our objects on deletion (postgres only)

## Delete Objects

**Example:** Delete a post object and return the deleted posts in the response:

{% tabs %}
{% tab title="Delete Objects" %}
<pre class="language-graphql"><code class="lang-graphql">mutation { 
<strong>    deletePosts() { 
</strong>        rows_affected 
        posts { 
            name 
            id 
        } 
    } 
}
</code></pre>
{% endtab %}

{% tab title="Delete With Filter" %}
```graphql
mutation { 
    deletePosts(filter: {id: {eq: 1}) { 
        rows_affected 
        posts { 
            name 
            id 
        } 
    } 
}
```
{% endtab %}
{% endtabs %}
