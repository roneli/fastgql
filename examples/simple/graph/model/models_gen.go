// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type BooleanComparator struct {
	Eq     *bool `json:"eq,omitempty" db:"eq"`
	Neq    *bool `json:"neq,omitempty" db:"neq"`
	IsNull *bool `json:"isNull,omitempty" db:"is_null"`
}

type BooleanListComparator struct {
	Eq        []*bool `json:"eq,omitempty" db:"eq"`
	Neq       []*bool `json:"neq,omitempty" db:"neq"`
	Contains  []*bool `json:"contains,omitempty" db:"contains"`
	Contained []*bool `json:"contained,omitempty" db:"contained"`
	Overlap   []*bool `json:"overlap,omitempty" db:"overlap"`
	IsNull    *bool   `json:"isNull,omitempty" db:"is_null"`
}

// Aggregate Category
type CategoriesAggregate struct {
	// Group
	Group map[string]any `json:"group,omitempty" db:"group"`
	// Count results
	Count int `json:"count" db:"count"`
	// Max Aggregate
	Max *CategoryMax `json:"max" db:"max"`
	// Min Aggregate
	Min *CategoryMin `json:"min" db:"min"`
	// Avg Aggregate
	Avg *CategoryAvg `json:"avg" db:"avg"`
	// Sum Aggregate
	Sum *CategorySum `json:"sum" db:"sum"`
}

// Ordering for CategoriesAggregate
type CategoriesAggregateOrdering struct {
	// Order CategoriesAggregate by group
	Group *OrderingTypes `json:"group,omitempty" db:"group"`
	// Order CategoriesAggregate by count
	Count *OrderingTypes `json:"count,omitempty" db:"count"`
}

// Aggregate CategoriesAggregate
type CategoriesAggregatesAggregate struct {
	// Group
	Group map[string]any `json:"group,omitempty" db:"group"`
	// Count results
	Count int `json:"count" db:"count"`
	// Max Aggregate
	Max *CategoriesAggregateMax `json:"max" db:"max"`
	// Min Aggregate
	Min *CategoriesAggregateMin `json:"min" db:"min"`
	// Avg Aggregate
	Avg *CategoriesAggregateAvg `json:"avg" db:"avg"`
	// Sum Aggregate
	Sum *CategoriesAggregateSum `json:"sum" db:"sum"`
}

type Category struct {
	ID   int     `json:"id" db:"id"`
	Name *string `json:"name,omitempty" db:"name"`
}

type CategoryFilterInput struct {
	ID   *IntComparator    `json:"id,omitempty" db:"id"`
	Name *StringComparator `json:"name,omitempty" db:"name"`
	// Logical AND of FilterInput
	And []*CategoryFilterInput `json:"AND,omitempty" db:"and"`
	// Logical OR of FilterInput
	Or []*CategoryFilterInput `json:"OR,omitempty" db:"or"`
	// Logical NOT of FilterInput
	Not *CategoryFilterInput `json:"NOT,omitempty" db:"not"`
}

// Ordering for Category
type CategoryOrdering struct {
	// Order Category by id
	ID *OrderingTypes `json:"id,omitempty" db:"id"`
	// Order Category by name
	Name *OrderingTypes `json:"name,omitempty" db:"name"`
}

type FloatComparator struct {
	Eq     *float64 `json:"eq,omitempty" db:"eq"`
	Neq    *float64 `json:"neq,omitempty" db:"neq"`
	Gt     *float64 `json:"gt,omitempty" db:"gt"`
	Gte    *float64 `json:"gte,omitempty" db:"gte"`
	Lt     *float64 `json:"lt,omitempty" db:"lt"`
	Lte    *float64 `json:"lte,omitempty" db:"lte"`
	IsNull *bool    `json:"isNull,omitempty" db:"is_null"`
}

type FloatListComparator struct {
	Eq        []*float64 `json:"eq,omitempty" db:"eq"`
	Neq       []*float64 `json:"neq,omitempty" db:"neq"`
	Contains  []*float64 `json:"contains,omitempty" db:"contains"`
	Contained []*float64 `json:"contained,omitempty" db:"contained"`
	Overlap   []*float64 `json:"overlap,omitempty" db:"overlap"`
	IsNull    *bool      `json:"isNull,omitempty" db:"is_null"`
}

type IntComparator struct {
	Eq     *int  `json:"eq,omitempty" db:"eq"`
	Neq    *int  `json:"neq,omitempty" db:"neq"`
	Gt     *int  `json:"gt,omitempty" db:"gt"`
	Gte    *int  `json:"gte,omitempty" db:"gte"`
	Lt     *int  `json:"lt,omitempty" db:"lt"`
	Lte    *int  `json:"lte,omitempty" db:"lte"`
	IsNull *bool `json:"isNull,omitempty" db:"is_null"`
}

type IntListComparator struct {
	Eq        []*int `json:"eq,omitempty" db:"eq"`
	Neq       []*int `json:"neq,omitempty" db:"neq"`
	Contains  []*int `json:"contains,omitempty" db:"contains"`
	Contained []*int `json:"contained,omitempty" db:"contained"`
	Overlap   []*int `json:"overlap,omitempty" db:"overlap"`
	IsNull    *bool  `json:"isNull,omitempty" db:"is_null"`
}

type Post struct {
	ID         int         `json:"id" db:"id"`
	Name       *string     `json:"name,omitempty" db:"name"`
	Categories []*Category `json:"categories,omitempty" db:"categories"`
	User       *User       `json:"user,omitempty" db:"user"`
	// categories Aggregate
	CategoriesAggregate []CategoriesAggregate `json:"_categoriesAggregate" db:"_categories_aggregate"`
	// user Aggregate
	UserAggregate []UsersAggregate `json:"_userAggregate" db:"_user_aggregate"`
}

type PostFilterInput struct {
	ID         *IntComparator       `json:"id,omitempty" db:"id"`
	Name       *StringComparator    `json:"name,omitempty" db:"name"`
	Categories *CategoryFilterInput `json:"categories,omitempty" db:"categories"`
	User       *UserFilterInput     `json:"user,omitempty" db:"user"`
	// Logical AND of FilterInput
	And []*PostFilterInput `json:"AND,omitempty" db:"and"`
	// Logical OR of FilterInput
	Or []*PostFilterInput `json:"OR,omitempty" db:"or"`
	// Logical NOT of FilterInput
	Not *PostFilterInput `json:"NOT,omitempty" db:"not"`
}

// Ordering for Post
type PostOrdering struct {
	// Order Post by id
	ID *OrderingTypes `json:"id,omitempty" db:"id"`
	// Order Post by name
	Name *OrderingTypes `json:"name,omitempty" db:"name"`
}

// Aggregate Post
type PostsAggregate struct {
	// Group
	Group map[string]any `json:"group,omitempty" db:"group"`
	// Count results
	Count int `json:"count" db:"count"`
	// Max Aggregate
	Max *PostMax `json:"max" db:"max"`
	// Min Aggregate
	Min *PostMin `json:"min" db:"min"`
	// Avg Aggregate
	Avg *PostAvg `json:"avg" db:"avg"`
	// Sum Aggregate
	Sum *PostSum `json:"sum" db:"sum"`
}

// Ordering for PostsAggregate
type PostsAggregateOrdering struct {
	// Order PostsAggregate by group
	Group *OrderingTypes `json:"group,omitempty" db:"group"`
	// Order PostsAggregate by count
	Count *OrderingTypes `json:"count,omitempty" db:"count"`
}

// Aggregate PostsAggregate
type PostsAggregatesAggregate struct {
	// Group
	Group map[string]any `json:"group,omitempty" db:"group"`
	// Count results
	Count int `json:"count" db:"count"`
	// Max Aggregate
	Max *PostsAggregateMax `json:"max" db:"max"`
	// Min Aggregate
	Min *PostsAggregateMin `json:"min" db:"min"`
	// Avg Aggregate
	Avg *PostsAggregateAvg `json:"avg" db:"avg"`
	// Sum Aggregate
	Sum *PostsAggregateSum `json:"sum" db:"sum"`
}

type Query struct {
}

type StringComparator struct {
	Eq          *string   `json:"eq,omitempty" db:"eq"`
	Neq         *string   `json:"neq,omitempty" db:"neq"`
	Contains    []*string `json:"contains,omitempty" db:"contains"`
	NotContains []*string `json:"notContains,omitempty" db:"not_contains"`
	Like        *string   `json:"like,omitempty" db:"like"`
	Ilike       *string   `json:"ilike,omitempty" db:"ilike"`
	Suffix      *string   `json:"suffix,omitempty" db:"suffix"`
	Prefix      *string   `json:"prefix,omitempty" db:"prefix"`
	IsNull      *bool     `json:"isNull,omitempty" db:"is_null"`
}

type StringListComparator struct {
	Eq          []*string `json:"eq,omitempty" db:"eq"`
	Neq         []*string `json:"neq,omitempty" db:"neq"`
	Contains    []*string `json:"contains,omitempty" db:"contains"`
	ContainedBy []*string `json:"containedBy,omitempty" db:"contained_by"`
	Overlap     []*string `json:"overlap,omitempty" db:"overlap"`
	IsNull      *bool     `json:"isNull,omitempty" db:"is_null"`
}

type User struct {
	ID    int     `json:"id" db:"id"`
	Name  string  `json:"name" db:"name"`
	Posts []*Post `json:"posts,omitempty" db:"posts"`
}

type UserFilterInput struct {
	ID    *IntComparator    `json:"id,omitempty" db:"id"`
	Name  *StringComparator `json:"name,omitempty" db:"name"`
	Posts *PostFilterInput  `json:"posts,omitempty" db:"posts"`
	// Logical AND of FilterInput
	And []*UserFilterInput `json:"AND,omitempty" db:"and"`
	// Logical OR of FilterInput
	Or []*UserFilterInput `json:"OR,omitempty" db:"or"`
	// Logical NOT of FilterInput
	Not *UserFilterInput `json:"NOT,omitempty" db:"not"`
}

// max aggregator for User
type UserMin struct {
	// Compute the maxiumum for name
	Name string `json:"name" db:"name"`
	// Compute the maxiumum for age
	Age int `json:"age" db:"age"`
}

// Ordering for User
type UserOrdering struct {
	// Order User by id
	ID *OrderingTypes `json:"id,omitempty" db:"id"`
	// Order User by name
	Name *OrderingTypes `json:"name,omitempty" db:"name"`
}

// Aggregate User
type UsersAggregate struct {
	// Count results
	Count int `json:"count" db:"count"`
	// Computes the maximum of the non-null input values.
	Max *UserMin `json:"max,omitempty" db:"max"`
	// Computes the minimum of the non-null input values.
	Min *UserMin `json:"min,omitempty" db:"min"`
}

// Ordering for UsersAggregate
type UsersAggregateOrdering struct {
	// Order UsersAggregate by count
	Count *OrderingTypes `json:"count,omitempty" db:"count"`
}

// Aggregate UsersAggregate
type UsersAggregatesAggregate struct {
	// Group
	Group map[string]any `json:"group,omitempty" db:"group"`
	// Count results
	Count int `json:"count" db:"count"`
	// Max Aggregate
	Max *UsersAggregateMax `json:"max" db:"max"`
	// Min Aggregate
	Min *UsersAggregateMin `json:"min" db:"min"`
	// Avg Aggregate
	Avg *UsersAggregateAvg `json:"avg" db:"avg"`
	// Sum Aggregate
	Sum *UsersAggregateSum `json:"sum" db:"sum"`
}

type AggregateResult struct {
	Count int `json:"count" db:"count"`
}

// avg Aggregate
type CategoriesAggregateAvg struct {
	// Compute the avg for count
	Count float64 `json:"count" db:"count"`
}

// max Aggregate
type CategoriesAggregateMax struct {
	// Compute the max for count
	Count int `json:"count" db:"count"`
}

// min Aggregate
type CategoriesAggregateMin struct {
	// Compute the min for count
	Count int `json:"count" db:"count"`
}

// sum Aggregate
type CategoriesAggregateSum struct {
	// Compute the sum for count
	Count float64 `json:"count" db:"count"`
}

// avg Aggregate
type CategoryAvg struct {
	// Compute the avg for id
	ID float64 `json:"id" db:"id"`
}

// max Aggregate
type CategoryMax struct {
	// Compute the max for id
	ID int `json:"id" db:"id"`
	// Compute the max for name
	Name string `json:"name" db:"name"`
}

// min Aggregate
type CategoryMin struct {
	// Compute the min for id
	ID int `json:"id" db:"id"`
	// Compute the min for name
	Name string `json:"name" db:"name"`
}

// sum Aggregate
type CategorySum struct {
	// Compute the sum for id
	ID float64 `json:"id" db:"id"`
}

// avg Aggregate
type PostAvg struct {
	// Compute the avg for id
	ID float64 `json:"id" db:"id"`
}

// max Aggregate
type PostMax struct {
	// Compute the max for id
	ID int `json:"id" db:"id"`
	// Compute the max for name
	Name string `json:"name" db:"name"`
}

// min Aggregate
type PostMin struct {
	// Compute the min for id
	ID int `json:"id" db:"id"`
	// Compute the min for name
	Name string `json:"name" db:"name"`
}

// sum Aggregate
type PostSum struct {
	// Compute the sum for id
	ID float64 `json:"id" db:"id"`
}

// avg Aggregate
type PostsAggregateAvg struct {
	// Compute the avg for count
	Count float64 `json:"count" db:"count"`
}

// max Aggregate
type PostsAggregateMax struct {
	// Compute the max for count
	Count int `json:"count" db:"count"`
}

// min Aggregate
type PostsAggregateMin struct {
	// Compute the min for count
	Count int `json:"count" db:"count"`
}

// sum Aggregate
type PostsAggregateSum struct {
	// Compute the sum for count
	Count float64 `json:"count" db:"count"`
}

// avg Aggregate
type UsersAggregateAvg struct {
	// Compute the avg for count
	Count float64 `json:"count" db:"count"`
}

// max Aggregate
type UsersAggregateMax struct {
	// Compute the max for count
	Count int `json:"count" db:"count"`
}

// min Aggregate
type UsersAggregateMin struct {
	// Compute the min for count
	Count int `json:"count" db:"count"`
}

// sum Aggregate
type UsersAggregateSum struct {
	// Compute the sum for count
	Count float64 `json:"count" db:"count"`
}

// Group by CategoriesAggregate
type CategoriesAggregateGroupBy string

const (
	// Group by group
	CategoriesAggregateGroupByGroup CategoriesAggregateGroupBy = "GROUP"
	// Group by count
	CategoriesAggregateGroupByCount CategoriesAggregateGroupBy = "COUNT"
)

var AllCategoriesAggregateGroupBy = []CategoriesAggregateGroupBy{
	CategoriesAggregateGroupByGroup,
	CategoriesAggregateGroupByCount,
}

func (e CategoriesAggregateGroupBy) IsValid() bool {
	switch e {
	case CategoriesAggregateGroupByGroup, CategoriesAggregateGroupByCount:
		return true
	}
	return false
}

func (e CategoriesAggregateGroupBy) String() string {
	return string(e)
}

func (e *CategoriesAggregateGroupBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CategoriesAggregateGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CategoriesAggregateGroupBy", str)
	}
	return nil
}

func (e CategoriesAggregateGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CategoriesAggregateGroupBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CategoriesAggregateGroupBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Group by Category
type CategoryGroupBy string

const (
	// Group by id
	CategoryGroupByID CategoryGroupBy = "ID"
	// Group by name
	CategoryGroupByName CategoryGroupBy = "NAME"
)

var AllCategoryGroupBy = []CategoryGroupBy{
	CategoryGroupByID,
	CategoryGroupByName,
}

func (e CategoryGroupBy) IsValid() bool {
	switch e {
	case CategoryGroupByID, CategoryGroupByName:
		return true
	}
	return false
}

func (e CategoryGroupBy) String() string {
	return string(e)
}

func (e *CategoryGroupBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CategoryGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CategoryGroupBy", str)
	}
	return nil
}

func (e CategoryGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CategoryGroupBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CategoryGroupBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Group by Post
type PostGroupBy string

const (
	// Group by id
	PostGroupByID PostGroupBy = "ID"
	// Group by name
	PostGroupByName PostGroupBy = "NAME"
)

var AllPostGroupBy = []PostGroupBy{
	PostGroupByID,
	PostGroupByName,
}

func (e PostGroupBy) IsValid() bool {
	switch e {
	case PostGroupByID, PostGroupByName:
		return true
	}
	return false
}

func (e PostGroupBy) String() string {
	return string(e)
}

func (e *PostGroupBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostGroupBy", str)
	}
	return nil
}

func (e PostGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PostGroupBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PostGroupBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Group by PostsAggregate
type PostsAggregateGroupBy string

const (
	// Group by group
	PostsAggregateGroupByGroup PostsAggregateGroupBy = "GROUP"
	// Group by count
	PostsAggregateGroupByCount PostsAggregateGroupBy = "COUNT"
)

var AllPostsAggregateGroupBy = []PostsAggregateGroupBy{
	PostsAggregateGroupByGroup,
	PostsAggregateGroupByCount,
}

func (e PostsAggregateGroupBy) IsValid() bool {
	switch e {
	case PostsAggregateGroupByGroup, PostsAggregateGroupByCount:
		return true
	}
	return false
}

func (e PostsAggregateGroupBy) String() string {
	return string(e)
}

func (e *PostsAggregateGroupBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostsAggregateGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostsAggregateGroupBy", str)
	}
	return nil
}

func (e PostsAggregateGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PostsAggregateGroupBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PostsAggregateGroupBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Group by User
type UserGroupBy string

const (
	// Group by name
	UserGroupByName UserGroupBy = "NAME"
	// Group by age
	UserGroupByAge UserGroupBy = "AGE"
)

var AllUserGroupBy = []UserGroupBy{
	UserGroupByName,
	UserGroupByAge,
}

func (e UserGroupBy) IsValid() bool {
	switch e {
	case UserGroupByName, UserGroupByAge:
		return true
	}
	return false
}

func (e UserGroupBy) String() string {
	return string(e)
}

func (e *UserGroupBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserGroupBy", str)
	}
	return nil
}

func (e UserGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UserGroupBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UserGroupBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// Group by UsersAggregate
type UsersAggregateGroupBy string

const (
	// Group by count
	UsersAggregateGroupByCount UsersAggregateGroupBy = "COUNT"
)

var AllUsersAggregateGroupBy = []UsersAggregateGroupBy{
	UsersAggregateGroupByCount,
}

func (e UsersAggregateGroupBy) IsValid() bool {
	switch e {
	case UsersAggregateGroupByCount:
		return true
	}
	return false
}

func (e UsersAggregateGroupBy) String() string {
	return string(e)
}

func (e *UsersAggregateGroupBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersAggregateGroupBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UsersAggregateGroupBy", str)
	}
	return nil
}

func (e UsersAggregateGroupBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UsersAggregateGroupBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UsersAggregateGroupBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OrderingTypes string

const (
	OrderingTypesAsc           OrderingTypes = "ASC"
	OrderingTypesDesc          OrderingTypes = "DESC"
	OrderingTypesAscNullFirst  OrderingTypes = "ASC_NULL_FIRST"
	OrderingTypesDescNullFirst OrderingTypes = "DESC_NULL_FIRST"
	OrderingTypesAscNullLast   OrderingTypes = "ASC_NULL_LAST"
	OrderingTypesDescNullLast  OrderingTypes = "DESC_NULL_LAST"
)

var AllOrderingTypes = []OrderingTypes{
	OrderingTypesAsc,
	OrderingTypesDesc,
	OrderingTypesAscNullFirst,
	OrderingTypesDescNullFirst,
	OrderingTypesAscNullLast,
	OrderingTypesDescNullLast,
}

func (e OrderingTypes) IsValid() bool {
	switch e {
	case OrderingTypesAsc, OrderingTypesDesc, OrderingTypesAscNullFirst, OrderingTypesDescNullFirst, OrderingTypesAscNullLast, OrderingTypesDescNullLast:
		return true
	}
	return false
}

func (e OrderingTypes) String() string {
	return string(e)
}

func (e *OrderingTypes) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderingTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid _OrderingTypes", str)
	}
	return nil
}

func (e OrderingTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderingTypes) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderingTypes) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RelationType string

const (
	RelationTypeOneToOne   RelationType = "ONE_TO_ONE"
	RelationTypeOneToMany  RelationType = "ONE_TO_MANY"
	RelationTypeManyToMany RelationType = "MANY_TO_MANY"
)

var AllRelationType = []RelationType{
	RelationTypeOneToOne,
	RelationTypeOneToMany,
	RelationTypeManyToMany,
}

func (e RelationType) IsValid() bool {
	switch e {
	case RelationTypeOneToOne, RelationTypeOneToMany, RelationTypeManyToMany:
		return true
	}
	return false
}

func (e RelationType) String() string {
	return string(e)
}

func (e *RelationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RelationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid _relationType", str)
	}
	return nil
}

func (e RelationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RelationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RelationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
