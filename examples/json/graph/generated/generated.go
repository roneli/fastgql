// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	model1 "github.com/roneli/fastgql/examples/interface/graph/model"
	"github.com/roneli/fastgql/examples/json/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
	FastgqlField func(ctx context.Context, obj any, next graphql.Resolver, skipSelect *bool) (res any, err error)
	Typename     func(ctx context.Context, obj any, next graphql.Resolver, name string) (res any, err error)
}

type ComplexityRoot struct {
	Dimensions struct {
		Depth  func(childComplexity int) int
		Height func(childComplexity int) int
		Width  func(childComplexity int) int
	}

	Product struct {
		Attributes func(childComplexity int) int
		ID         func(childComplexity int) int
		Metadata   func(childComplexity int) int
		Name       func(childComplexity int) int
	}

	ProductAttributes struct {
		Color   func(childComplexity int) int
		Details func(childComplexity int) int
		Size    func(childComplexity int) int
		Specs   func(childComplexity int) int
		Tags    func(childComplexity int) int
	}

	ProductDetails struct {
		Manufacturer func(childComplexity int) int
		Model        func(childComplexity int) int
		Warranty     func(childComplexity int) int
	}

	ProductsAggregate struct {
		Avg   func(childComplexity int) int
		Count func(childComplexity int) int
		Group func(childComplexity int) int
		Max   func(childComplexity int) int
		Min   func(childComplexity int) int
		Sum   func(childComplexity int) int
	}

	Query struct {
		Products          func(childComplexity int, limit *int, offset *int, orderBy []*model.ProductOrdering, filter *model.ProductFilterInput) int
		ProductsAggregate func(childComplexity int, groupBy []model.ProductGroupBy, filter *model.ProductFilterInput) int
	}

	Specs struct {
		Dimensions func(childComplexity int) int
		Weight     func(childComplexity int) int
	}

	WarrantyInfo struct {
		Provider func(childComplexity int) int
		Years    func(childComplexity int) int
	}

	_AggregateResult struct {
		Count func(childComplexity int) int
	}

	_ProductAvg struct {
		ID func(childComplexity int) int
	}

	_ProductMax struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	_ProductMin struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	_ProductSum struct {
		ID func(childComplexity int) int
	}
}

type QueryResolver interface {
	Products(ctx context.Context, limit *int, offset *int, orderBy []*model.ProductOrdering, filter *model.ProductFilterInput) ([]*model.Product, error)
	ProductsAggregate(ctx context.Context, groupBy []model.ProductGroupBy, filter *model.ProductFilterInput) ([]*model.ProductsAggregate, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Dimensions.depth":
		if e.complexity.Dimensions.Depth == nil {
			break
		}

		return e.complexity.Dimensions.Depth(childComplexity), true
	case "Dimensions.height":
		if e.complexity.Dimensions.Height == nil {
			break
		}

		return e.complexity.Dimensions.Height(childComplexity), true
	case "Dimensions.width":
		if e.complexity.Dimensions.Width == nil {
			break
		}

		return e.complexity.Dimensions.Width(childComplexity), true

	case "Product.attributes":
		if e.complexity.Product.Attributes == nil {
			break
		}

		return e.complexity.Product.Attributes(childComplexity), true
	case "Product.id":
		if e.complexity.Product.ID == nil {
			break
		}

		return e.complexity.Product.ID(childComplexity), true
	case "Product.metadata":
		if e.complexity.Product.Metadata == nil {
			break
		}

		return e.complexity.Product.Metadata(childComplexity), true
	case "Product.name":
		if e.complexity.Product.Name == nil {
			break
		}

		return e.complexity.Product.Name(childComplexity), true

	case "ProductAttributes.color":
		if e.complexity.ProductAttributes.Color == nil {
			break
		}

		return e.complexity.ProductAttributes.Color(childComplexity), true
	case "ProductAttributes.details":
		if e.complexity.ProductAttributes.Details == nil {
			break
		}

		return e.complexity.ProductAttributes.Details(childComplexity), true
	case "ProductAttributes.size":
		if e.complexity.ProductAttributes.Size == nil {
			break
		}

		return e.complexity.ProductAttributes.Size(childComplexity), true
	case "ProductAttributes.specs":
		if e.complexity.ProductAttributes.Specs == nil {
			break
		}

		return e.complexity.ProductAttributes.Specs(childComplexity), true
	case "ProductAttributes.tags":
		if e.complexity.ProductAttributes.Tags == nil {
			break
		}

		return e.complexity.ProductAttributes.Tags(childComplexity), true

	case "ProductDetails.manufacturer":
		if e.complexity.ProductDetails.Manufacturer == nil {
			break
		}

		return e.complexity.ProductDetails.Manufacturer(childComplexity), true
	case "ProductDetails.model":
		if e.complexity.ProductDetails.Model == nil {
			break
		}

		return e.complexity.ProductDetails.Model(childComplexity), true
	case "ProductDetails.warranty":
		if e.complexity.ProductDetails.Warranty == nil {
			break
		}

		return e.complexity.ProductDetails.Warranty(childComplexity), true

	case "ProductsAggregate.avg":
		if e.complexity.ProductsAggregate.Avg == nil {
			break
		}

		return e.complexity.ProductsAggregate.Avg(childComplexity), true
	case "ProductsAggregate.count":
		if e.complexity.ProductsAggregate.Count == nil {
			break
		}

		return e.complexity.ProductsAggregate.Count(childComplexity), true
	case "ProductsAggregate.group":
		if e.complexity.ProductsAggregate.Group == nil {
			break
		}

		return e.complexity.ProductsAggregate.Group(childComplexity), true
	case "ProductsAggregate.max":
		if e.complexity.ProductsAggregate.Max == nil {
			break
		}

		return e.complexity.ProductsAggregate.Max(childComplexity), true
	case "ProductsAggregate.min":
		if e.complexity.ProductsAggregate.Min == nil {
			break
		}

		return e.complexity.ProductsAggregate.Min(childComplexity), true
	case "ProductsAggregate.sum":
		if e.complexity.ProductsAggregate.Sum == nil {
			break
		}

		return e.complexity.ProductsAggregate.Sum(childComplexity), true

	case "Query.products":
		if e.complexity.Query.Products == nil {
			break
		}

		args, err := ec.field_Query_products_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Products(childComplexity, args["limit"].(*int), args["offset"].(*int), args["orderBy"].([]*model.ProductOrdering), args["filter"].(*model.ProductFilterInput)), true
	case "Query._productsAggregate":
		if e.complexity.Query.ProductsAggregate == nil {
			break
		}

		args, err := ec.field_Query__productsAggregate_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProductsAggregate(childComplexity, args["groupBy"].([]model.ProductGroupBy), args["filter"].(*model.ProductFilterInput)), true

	case "Specs.dimensions":
		if e.complexity.Specs.Dimensions == nil {
			break
		}

		return e.complexity.Specs.Dimensions(childComplexity), true
	case "Specs.weight":
		if e.complexity.Specs.Weight == nil {
			break
		}

		return e.complexity.Specs.Weight(childComplexity), true

	case "WarrantyInfo.provider":
		if e.complexity.WarrantyInfo.Provider == nil {
			break
		}

		return e.complexity.WarrantyInfo.Provider(childComplexity), true
	case "WarrantyInfo.years":
		if e.complexity.WarrantyInfo.Years == nil {
			break
		}

		return e.complexity.WarrantyInfo.Years(childComplexity), true

	case "_AggregateResult.count":
		if e.complexity._AggregateResult.Count == nil {
			break
		}

		return e.complexity._AggregateResult.Count(childComplexity), true

	case "_ProductAvg.id":
		if e.complexity._ProductAvg.ID == nil {
			break
		}

		return e.complexity._ProductAvg.ID(childComplexity), true

	case "_ProductMax.id":
		if e.complexity._ProductMax.ID == nil {
			break
		}

		return e.complexity._ProductMax.ID(childComplexity), true
	case "_ProductMax.name":
		if e.complexity._ProductMax.Name == nil {
			break
		}

		return e.complexity._ProductMax.Name(childComplexity), true

	case "_ProductMin.id":
		if e.complexity._ProductMin.ID == nil {
			break
		}

		return e.complexity._ProductMin.ID(childComplexity), true
	case "_ProductMin.name":
		if e.complexity._ProductMin.Name == nil {
			break
		}

		return e.complexity._ProductMin.Name(childComplexity), true

	case "_ProductSum.id":
		if e.complexity._ProductSum.ID == nil {
			break
		}

		return e.complexity._ProductSum.ID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBooleanComparator,
		ec.unmarshalInputBooleanListComparator,
		ec.unmarshalInputDimensionsFilterInput,
		ec.unmarshalInputFloatComparator,
		ec.unmarshalInputFloatListComparator,
		ec.unmarshalInputIDComparator,
		ec.unmarshalInputIntComparator,
		ec.unmarshalInputIntListComparator,
		ec.unmarshalInputMapComparator,
		ec.unmarshalInputMapPathCondition,
		ec.unmarshalInputProductAttributesFilterInput,
		ec.unmarshalInputProductDetailsFilterInput,
		ec.unmarshalInputProductFilterInput,
		ec.unmarshalInputProductOrdering,
		ec.unmarshalInputSpecsFilterInput,
		ec.unmarshalInputStringComparator,
		ec.unmarshalInputStringListComparator,
		ec.unmarshalInputWarrantyInfoFilterInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../fastgql_schema.graphql", Input: `"""
Filter input for JSON type Dimensions
"""
input DimensionsFilterInput {
	width: FloatComparator
	height: FloatComparator
	depth: FloatComparator
	"""
	Logical AND of FilterInput
	"""
	AND: [DimensionsFilterInput]
	"""
	Logical OR of FilterInput
	"""
	OR: [DimensionsFilterInput]
	"""
	Logical NOT of FilterInput
	"""
	NOT: DimensionsFilterInput
}
"""
Filter input for JSON type ProductAttributes
"""
input ProductAttributesFilterInput {
	color: StringComparator
	size: IntComparator
	tags: StringListComparator
	details: ProductDetailsFilterInput
	specs: SpecsFilterInput
	"""
	Logical AND of FilterInput
	"""
	AND: [ProductAttributesFilterInput]
	"""
	Logical OR of FilterInput
	"""
	OR: [ProductAttributesFilterInput]
	"""
	Logical NOT of FilterInput
	"""
	NOT: ProductAttributesFilterInput
}
"""
Filter input for JSON type ProductDetails
"""
input ProductDetailsFilterInput {
	manufacturer: StringComparator
	model: StringComparator
	warranty: WarrantyInfoFilterInput
	"""
	Logical AND of FilterInput
	"""
	AND: [ProductDetailsFilterInput]
	"""
	Logical OR of FilterInput
	"""
	OR: [ProductDetailsFilterInput]
	"""
	Logical NOT of FilterInput
	"""
	NOT: ProductDetailsFilterInput
}
input ProductFilterInput {
	id: IntComparator
	name: StringComparator
	attributes: ProductAttributesFilterInput
	metadata: MapComparator
	"""
	Logical AND of FilterInput
	"""
	AND: [ProductFilterInput]
	"""
	Logical OR of FilterInput
	"""
	OR: [ProductFilterInput]
	"""
	Logical NOT of FilterInput
	"""
	NOT: ProductFilterInput
}
"""
Group by Product
"""
enum ProductGroupBy {
	"""
	Group by id
	"""
	ID
	"""
	Group by name
	"""
	NAME
	"""
	Group by metadata
	"""
	METADATA
}
"""
Ordering for Product
"""
input ProductOrdering {
	"""
	Order Product by id
	"""
	id: _OrderingTypes
	"""
	Order Product by name
	"""
	name: _OrderingTypes
	"""
	Order Product by metadata
	"""
	metadata: _OrderingTypes
}
"""
Aggregate Product
"""
type ProductsAggregate {
	"""
	Group
	"""
	group: Map
	"""
	Count results
	"""
	count: Int!
	"""
	Max Aggregate
	"""
	max: _ProductMax!
	"""
	Min Aggregate
	"""
	min: _ProductMin!
	"""
	Avg Aggregate
	"""
	avg: _ProductAvg!
	"""
	Sum Aggregate
	"""
	sum: _ProductSum!
}
"""
Filter input for JSON type Specs
"""
input SpecsFilterInput {
	weight: FloatComparator
	dimensions: DimensionsFilterInput
	"""
	Logical AND of FilterInput
	"""
	AND: [SpecsFilterInput]
	"""
	Logical OR of FilterInput
	"""
	OR: [SpecsFilterInput]
	"""
	Logical NOT of FilterInput
	"""
	NOT: SpecsFilterInput
}
"""
Filter input for JSON type WarrantyInfo
"""
input WarrantyInfoFilterInput {
	years: IntComparator
	provider: StringComparator
	"""
	Logical AND of FilterInput
	"""
	AND: [WarrantyInfoFilterInput]
	"""
	Logical OR of FilterInput
	"""
	OR: [WarrantyInfoFilterInput]
	"""
	Logical NOT of FilterInput
	"""
	NOT: WarrantyInfoFilterInput
}
"""
avg Aggregate
"""
type _ProductAvg {
	"""
	Compute the avg for id
	"""
	id: Float!
}
"""
max Aggregate
"""
type _ProductMax {
	"""
	Compute the max for id
	"""
	id: Int!
	"""
	Compute the max for name
	"""
	name: String!
}
"""
min Aggregate
"""
type _ProductMin {
	"""
	Compute the min for id
	"""
	id: Int!
	"""
	Compute the min for name
	"""
	name: String!
}
"""
sum Aggregate
"""
type _ProductSum {
	"""
	Compute the sum for id
	"""
	id: Float!
}
`, BuiltIn: false},
	{Name: "../fastgql.graphql", Input: `directive @fastgqlField(skipSelect: Boolean = True) on FIELD_DEFINITION
directive @generate(filter: Boolean = True, pagination: Boolean = True, ordering: Boolean = True, aggregate: Boolean = True, recursive: Boolean = True, filterTypeName: String) on FIELD_DEFINITION
directive @generateFilterInput(description: String) on OBJECT | INTERFACE
directive @generateMutations(create: Boolean = True, delete: Boolean = True, update: Boolean = True) on OBJECT
directive @isInterfaceFilter on INPUT_FIELD_DEFINITION
directive @json(column: String!) on FIELD_DEFINITION
directive @relation(type: _relationType!, fields: [String!]!, references: [String!]!, manyToManyTable: String = "", manyToManyFields: [String] = [], manyToManyReferences: [String] = []) on FIELD_DEFINITION
directive @table(name: String!, dialect: String! = "postgres", schema: String = "") on OBJECT | INTERFACE
directive @typename(name: String!) on INTERFACE
input BooleanComparator {
	eq: Boolean
	neq: Boolean
	isNull: Boolean
}
input BooleanListComparator {
	eq: [Boolean]
	neq: [Boolean]
	contains: [Boolean]
	contained: [Boolean]
	overlap: [Boolean]
	isNull: Boolean
}
input FloatComparator {
	eq: Float
	neq: Float
	gt: Float
	gte: Float
	lt: Float
	lte: Float
	isNull: Boolean
}
input FloatListComparator {
	eq: [Float]
	neq: [Float]
	contains: [Float]
	contained: [Float]
	overlap: [Float]
	isNull: Boolean
}
input IDComparator {
	eq: ID
	neq: ID
	isNull: Boolean
}
input IntComparator {
	eq: Int
	neq: Int
	gt: Int
	gte: Int
	lt: Int
	lte: Int
	isNull: Boolean
}
input IntListComparator {
	eq: [Int]
	neq: [Int]
	contains: [Int]
	contained: [Int]
	overlap: [Int]
	isNull: Boolean
}
scalar Map
input MapComparator {
	contains: Map
	where: [MapPathCondition!]
	whereAny: [MapPathCondition!]
	isNull: Boolean
}
input MapPathCondition {
	path: String!
	eq: String
	neq: String
	gt: Float
	gte: Float
	lt: Float
	lte: Float
	like: String
	isNull: Boolean
}
input StringComparator {
	eq: String
	neq: String
	contains: [String]
	notContains: [String]
	like: String
	ilike: String
	suffix: String
	prefix: String
	isNull: Boolean
}
input StringListComparator {
	eq: [String]
	neq: [String]
	contains: [String]
	containedBy: [String]
	overlap: [String]
	isNull: Boolean
}
type _AggregateResult {
	count: Int!
}
enum _OrderingTypes {
	ASC
	DESC
	ASC_NULL_FIRST
	DESC_NULL_FIRST
	ASC_NULL_LAST
	DESC_NULL_LAST
}
enum _relationType {
	ONE_TO_ONE
	ONE_TO_MANY
	MANY_TO_MANY
}
`, BuiltIn: false},
	{Name: "../schema.graphql", Input: `type Dimensions {
	width: Float
	height: Float
	depth: Float
}
type Product @generateFilterInput @table(name: "products", schema: "app") {
	id: Int!
	name: String!
	attributes: ProductAttributes @json(column: "attributes")
	metadata: Map
}
type ProductAttributes {
	color: String
	size: Int
	tags: [String]
	details: ProductDetails
	specs: Specs
}
type ProductDetails {
	manufacturer: String
	model: String
	warranty: WarrantyInfo
}
type Query {
	products(
		"""
		Limit
		"""
		limit: Int = 100,
		"""
		Offset
		"""
		offset: Int = 0,
		"""
		Ordering for Product
		"""
		orderBy: [ProductOrdering],
		"""
		Filter products
		"""
		filter: ProductFilterInput): [Product] @generate
	"""
	products Aggregate
	"""
	_productsAggregate(groupBy: [ProductGroupBy!],
		"""
		Filter _productsAggregate
		"""
		filter: ProductFilterInput): [ProductsAggregate!]! @generate(filter: true)
}
type Specs {
	weight: Float
	dimensions: Dimensions
}
type WarrantyInfo {
	years: Int
	provider: String
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_fastgqlField_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "skipSelect", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["skipSelect"] = arg0
	return args, nil
}

func (ec *executionContext) dir_typename_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query__productsAggregate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "groupBy", ec.unmarshalOProductGroupBy2ᚕgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductGroupByᚄ)
	if err != nil {
		return nil, err
	}
	args["groupBy"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOProductFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductFilterInput)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_products_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "limit", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "offset", ec.unmarshalOInt2ᚖint)
	if err != nil {
		return nil, err
	}
	args["offset"] = arg1
	arg2, err := graphql.ProcessArgField(ctx, rawArgs, "orderBy", ec.unmarshalOProductOrdering2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductOrdering)
	if err != nil {
		return nil, err
	}
	args["orderBy"] = arg2
	arg3, err := graphql.ProcessArgField(ctx, rawArgs, "filter", ec.unmarshalOProductFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductFilterInput)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg3
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2ᚖbool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Dimensions_width(ctx context.Context, field graphql.CollectedField, obj *model.Dimensions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Dimensions_width,
		func(ctx context.Context) (any, error) {
			return obj.Width, nil
		},
		nil,
		ec.marshalOFloat2ᚖfloat64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Dimensions_width(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dimensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dimensions_height(ctx context.Context, field graphql.CollectedField, obj *model.Dimensions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Dimensions_height,
		func(ctx context.Context) (any, error) {
			return obj.Height, nil
		},
		nil,
		ec.marshalOFloat2ᚖfloat64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Dimensions_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dimensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dimensions_depth(ctx context.Context, field graphql.CollectedField, obj *model.Dimensions) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Dimensions_depth,
		func(ctx context.Context) (any, error) {
			return obj.Depth, nil
		},
		nil,
		ec.marshalOFloat2ᚖfloat64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Dimensions_depth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dimensions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Product_id(ctx context.Context, field graphql.CollectedField, obj *model.Product) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Product_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Product_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Product",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Product_name(ctx context.Context, field graphql.CollectedField, obj *model.Product) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Product_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Product_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Product",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Product_attributes(ctx context.Context, field graphql.CollectedField, obj *model.Product) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Product_attributes,
		func(ctx context.Context) (any, error) {
			return obj.Attributes, nil
		},
		nil,
		ec.marshalOProductAttributes2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAttributes,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Product_attributes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Product",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "color":
				return ec.fieldContext_ProductAttributes_color(ctx, field)
			case "size":
				return ec.fieldContext_ProductAttributes_size(ctx, field)
			case "tags":
				return ec.fieldContext_ProductAttributes_tags(ctx, field)
			case "details":
				return ec.fieldContext_ProductAttributes_details(ctx, field)
			case "specs":
				return ec.fieldContext_ProductAttributes_specs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProductAttributes", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Product_metadata(ctx context.Context, field graphql.CollectedField, obj *model.Product) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Product_metadata,
		func(ctx context.Context) (any, error) {
			return obj.Metadata, nil
		},
		nil,
		ec.marshalOMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Product_metadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Product",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductAttributes_color(ctx context.Context, field graphql.CollectedField, obj *model.ProductAttributes) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductAttributes_color,
		func(ctx context.Context) (any, error) {
			return obj.Color, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProductAttributes_color(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductAttributes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductAttributes_size(ctx context.Context, field graphql.CollectedField, obj *model.ProductAttributes) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductAttributes_size,
		func(ctx context.Context) (any, error) {
			return obj.Size, nil
		},
		nil,
		ec.marshalOInt2ᚖint,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProductAttributes_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductAttributes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductAttributes_tags(ctx context.Context, field graphql.CollectedField, obj *model.ProductAttributes) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductAttributes_tags,
		func(ctx context.Context) (any, error) {
			return obj.Tags, nil
		},
		nil,
		ec.marshalOString2ᚕᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProductAttributes_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductAttributes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductAttributes_details(ctx context.Context, field graphql.CollectedField, obj *model.ProductAttributes) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductAttributes_details,
		func(ctx context.Context) (any, error) {
			return obj.Details, nil
		},
		nil,
		ec.marshalOProductDetails2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductDetails,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProductAttributes_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductAttributes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "manufacturer":
				return ec.fieldContext_ProductDetails_manufacturer(ctx, field)
			case "model":
				return ec.fieldContext_ProductDetails_model(ctx, field)
			case "warranty":
				return ec.fieldContext_ProductDetails_warranty(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProductDetails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductAttributes_specs(ctx context.Context, field graphql.CollectedField, obj *model.ProductAttributes) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductAttributes_specs,
		func(ctx context.Context) (any, error) {
			return obj.Specs, nil
		},
		nil,
		ec.marshalOSpecs2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐSpecs,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProductAttributes_specs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductAttributes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "weight":
				return ec.fieldContext_Specs_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Specs_dimensions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Specs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductDetails_manufacturer(ctx context.Context, field graphql.CollectedField, obj *model.ProductDetails) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductDetails_manufacturer,
		func(ctx context.Context) (any, error) {
			return obj.Manufacturer, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProductDetails_manufacturer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductDetails_model(ctx context.Context, field graphql.CollectedField, obj *model.ProductDetails) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductDetails_model,
		func(ctx context.Context) (any, error) {
			return obj.Model, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProductDetails_model(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductDetails_warranty(ctx context.Context, field graphql.CollectedField, obj *model.ProductDetails) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductDetails_warranty,
		func(ctx context.Context) (any, error) {
			return obj.Warranty, nil
		},
		nil,
		ec.marshalOWarrantyInfo2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐWarrantyInfo,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProductDetails_warranty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductDetails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "years":
				return ec.fieldContext_WarrantyInfo_years(ctx, field)
			case "provider":
				return ec.fieldContext_WarrantyInfo_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WarrantyInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductsAggregate_group(ctx context.Context, field graphql.CollectedField, obj *model.ProductsAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductsAggregate_group,
		func(ctx context.Context) (any, error) {
			return obj.Group, nil
		},
		nil,
		ec.marshalOMap2map,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ProductsAggregate_group(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductsAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductsAggregate_count(ctx context.Context, field graphql.CollectedField, obj *model.ProductsAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductsAggregate_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProductsAggregate_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductsAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductsAggregate_max(ctx context.Context, field graphql.CollectedField, obj *model.ProductsAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductsAggregate_max,
		func(ctx context.Context) (any, error) {
			return obj.Max, nil
		},
		nil,
		ec.marshalN_ProductMax2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductMax,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProductsAggregate_max(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductsAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext__ProductMax_id(ctx, field)
			case "name":
				return ec.fieldContext__ProductMax_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _ProductMax", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductsAggregate_min(ctx context.Context, field graphql.CollectedField, obj *model.ProductsAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductsAggregate_min,
		func(ctx context.Context) (any, error) {
			return obj.Min, nil
		},
		nil,
		ec.marshalN_ProductMin2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductMin,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProductsAggregate_min(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductsAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext__ProductMin_id(ctx, field)
			case "name":
				return ec.fieldContext__ProductMin_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _ProductMin", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductsAggregate_avg(ctx context.Context, field graphql.CollectedField, obj *model.ProductsAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductsAggregate_avg,
		func(ctx context.Context) (any, error) {
			return obj.Avg, nil
		},
		nil,
		ec.marshalN_ProductAvg2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAvg,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProductsAggregate_avg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductsAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext__ProductAvg_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _ProductAvg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProductsAggregate_sum(ctx context.Context, field graphql.CollectedField, obj *model.ProductsAggregate) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ProductsAggregate_sum,
		func(ctx context.Context) (any, error) {
			return obj.Sum, nil
		},
		nil,
		ec.marshalN_ProductSum2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductSum,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ProductsAggregate_sum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProductsAggregate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext__ProductSum_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type _ProductSum", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_products(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_products,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().Products(ctx, fc.Args["limit"].(*int), fc.Args["offset"].(*int), fc.Args["orderBy"].([]*model.ProductOrdering), fc.Args["filter"].(*model.ProductFilterInput))
		},
		nil,
		ec.marshalOProduct2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProduct,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_products(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Product_id(ctx, field)
			case "name":
				return ec.fieldContext_Product_name(ctx, field)
			case "attributes":
				return ec.fieldContext_Product_attributes(ctx, field)
			case "metadata":
				return ec.fieldContext_Product_metadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Product", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_products_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query__productsAggregate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query__productsAggregate,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ProductsAggregate(ctx, fc.Args["groupBy"].([]model.ProductGroupBy), fc.Args["filter"].(*model.ProductFilterInput))
		},
		nil,
		ec.marshalNProductsAggregate2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductsAggregateᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query__productsAggregate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "group":
				return ec.fieldContext_ProductsAggregate_group(ctx, field)
			case "count":
				return ec.fieldContext_ProductsAggregate_count(ctx, field)
			case "max":
				return ec.fieldContext_ProductsAggregate_max(ctx, field)
			case "min":
				return ec.fieldContext_ProductsAggregate_min(ctx, field)
			case "avg":
				return ec.fieldContext_ProductsAggregate_avg(ctx, field)
			case "sum":
				return ec.fieldContext_ProductsAggregate_sum(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProductsAggregate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query__productsAggregate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Specs_weight(ctx context.Context, field graphql.CollectedField, obj *model.Specs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Specs_weight,
		func(ctx context.Context) (any, error) {
			return obj.Weight, nil
		},
		nil,
		ec.marshalOFloat2ᚖfloat64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Specs_weight(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Specs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Specs_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.Specs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Specs_dimensions,
		func(ctx context.Context) (any, error) {
			return obj.Dimensions, nil
		},
		nil,
		ec.marshalODimensions2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐDimensions,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Specs_dimensions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Specs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "width":
				return ec.fieldContext_Dimensions_width(ctx, field)
			case "height":
				return ec.fieldContext_Dimensions_height(ctx, field)
			case "depth":
				return ec.fieldContext_Dimensions_depth(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dimensions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WarrantyInfo_years(ctx context.Context, field graphql.CollectedField, obj *model.WarrantyInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WarrantyInfo_years,
		func(ctx context.Context) (any, error) {
			return obj.Years, nil
		},
		nil,
		ec.marshalOInt2ᚖint,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WarrantyInfo_years(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WarrantyInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WarrantyInfo_provider(ctx context.Context, field graphql.CollectedField, obj *model.WarrantyInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WarrantyInfo_provider,
		func(ctx context.Context) (any, error) {
			return obj.Provider, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WarrantyInfo_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WarrantyInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __AggregateResult_count(ctx context.Context, field graphql.CollectedField, obj *model1.AggregateResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext__AggregateResult_count,
		func(ctx context.Context) (any, error) {
			return obj.Count, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext__AggregateResult_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_AggregateResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __ProductAvg_id(ctx context.Context, field graphql.CollectedField, obj *model.ProductAvg) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext__ProductAvg_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext__ProductAvg_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_ProductAvg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __ProductMax_id(ctx context.Context, field graphql.CollectedField, obj *model.ProductMax) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext__ProductMax_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext__ProductMax_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_ProductMax",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __ProductMax_name(ctx context.Context, field graphql.CollectedField, obj *model.ProductMax) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext__ProductMax_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext__ProductMax_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_ProductMax",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __ProductMin_id(ctx context.Context, field graphql.CollectedField, obj *model.ProductMin) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext__ProductMin_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext__ProductMin_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_ProductMin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __ProductMin_name(ctx context.Context, field graphql.CollectedField, obj *model.ProductMin) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext__ProductMin_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext__ProductMin_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_ProductMin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) __ProductSum_id(ctx context.Context, field graphql.CollectedField, obj *model.ProductSum) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext__ProductSum_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNFloat2float64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext__ProductSum_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "_ProductSum",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2ᚕstringᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBooleanComparator(ctx context.Context, obj any) (model1.BooleanComparator, error) {
	var it model1.BooleanComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "neq", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBooleanListComparator(ctx context.Context, obj any) (model1.BooleanListComparator, error) {
	var it model1.BooleanListComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "neq", "contains", "contained", "overlap", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOBoolean2ᚕᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOBoolean2ᚕᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "contains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contains"))
			data, err := ec.unmarshalOBoolean2ᚕᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Contains = data
		case "contained":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contained"))
			data, err := ec.unmarshalOBoolean2ᚕᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Contained = data
		case "overlap":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("overlap"))
			data, err := ec.unmarshalOBoolean2ᚕᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Overlap = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDimensionsFilterInput(ctx context.Context, obj any) (model.DimensionsFilterInput, error) {
	var it model.DimensionsFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"width", "height", "depth", "AND", "OR", "NOT"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalOFloatComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐFloatComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOFloatComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐFloatComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "depth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("depth"))
			data, err := ec.unmarshalOFloatComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐFloatComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Depth = data
		case "AND":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AND"))
			data, err := ec.unmarshalODimensionsFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐDimensionsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "OR":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("OR"))
			data, err := ec.unmarshalODimensionsFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐDimensionsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "NOT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NOT"))
			data, err := ec.unmarshalODimensionsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐDimensionsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFloatComparator(ctx context.Context, obj any) (model1.FloatComparator, error) {
	var it model1.FloatComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "neq", "gt", "gte", "lt", "lte", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "gt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gt = data
		case "gte":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gte"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gte = data
		case "lt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lt = data
		case "lte":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lte"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lte = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFloatListComparator(ctx context.Context, obj any) (model1.FloatListComparator, error) {
	var it model1.FloatListComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "neq", "contains", "contained", "overlap", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOFloat2ᚕᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOFloat2ᚕᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "contains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contains"))
			data, err := ec.unmarshalOFloat2ᚕᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Contains = data
		case "contained":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contained"))
			data, err := ec.unmarshalOFloat2ᚕᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Contained = data
		case "overlap":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("overlap"))
			data, err := ec.unmarshalOFloat2ᚕᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Overlap = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIDComparator(ctx context.Context, obj any) (model.IDComparator, error) {
	var it model.IDComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "neq", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntComparator(ctx context.Context, obj any) (model1.IntComparator, error) {
	var it model1.IntComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "neq", "gt", "gte", "lt", "lte", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "gt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gt = data
		case "gte":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gte"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gte = data
		case "lt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lt = data
		case "lte":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lte"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lte = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIntListComparator(ctx context.Context, obj any) (model1.IntListComparator, error) {
	var it model1.IntListComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "neq", "contains", "contained", "overlap", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "contains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contains"))
			data, err := ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Contains = data
		case "contained":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contained"))
			data, err := ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Contained = data
		case "overlap":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("overlap"))
			data, err := ec.unmarshalOInt2ᚕᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Overlap = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMapComparator(ctx context.Context, obj any) (model.MapComparator, error) {
	var it model.MapComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"contains", "where", "whereAny", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "contains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contains"))
			data, err := ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Contains = data
		case "where":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
			data, err := ec.unmarshalOMapPathCondition2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐMapPathConditionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Where = data
		case "whereAny":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("whereAny"))
			data, err := ec.unmarshalOMapPathCondition2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐMapPathConditionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.WhereAny = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMapPathCondition(ctx context.Context, obj any) (model.MapPathCondition, error) {
	var it model.MapPathCondition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"path", "eq", "neq", "gt", "gte", "lt", "lte", "like", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "gt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gt = data
		case "gte":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gte"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gte = data
		case "lt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lt = data
		case "lte":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lte"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lte = data
		case "like":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("like"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Like = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProductAttributesFilterInput(ctx context.Context, obj any) (model.ProductAttributesFilterInput, error) {
	var it model.ProductAttributesFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"color", "size", "tags", "details", "specs", "AND", "OR", "NOT"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalOStringComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOIntComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalOStringListComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐStringListComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "details":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("details"))
			data, err := ec.unmarshalOProductDetailsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductDetailsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Details = data
		case "specs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("specs"))
			data, err := ec.unmarshalOSpecsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐSpecsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Specs = data
		case "AND":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AND"))
			data, err := ec.unmarshalOProductAttributesFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAttributesFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "OR":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("OR"))
			data, err := ec.unmarshalOProductAttributesFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAttributesFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "NOT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NOT"))
			data, err := ec.unmarshalOProductAttributesFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAttributesFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProductDetailsFilterInput(ctx context.Context, obj any) (model.ProductDetailsFilterInput, error) {
	var it model.ProductDetailsFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"manufacturer", "model", "warranty", "AND", "OR", "NOT"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "manufacturer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manufacturer"))
			data, err := ec.unmarshalOStringComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manufacturer = data
		case "model":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("model"))
			data, err := ec.unmarshalOStringComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Model = data
		case "warranty":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("warranty"))
			data, err := ec.unmarshalOWarrantyInfoFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐWarrantyInfoFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Warranty = data
		case "AND":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AND"))
			data, err := ec.unmarshalOProductDetailsFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductDetailsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "OR":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("OR"))
			data, err := ec.unmarshalOProductDetailsFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductDetailsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "NOT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NOT"))
			data, err := ec.unmarshalOProductDetailsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductDetailsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProductFilterInput(ctx context.Context, obj any) (model.ProductFilterInput, error) {
	var it model.ProductFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "attributes", "metadata", "AND", "OR", "NOT"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOIntComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOStringComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "attributes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attributes"))
			data, err := ec.unmarshalOProductAttributesFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAttributesFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Attributes = data
		case "metadata":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metadata"))
			data, err := ec.unmarshalOMapComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐMapComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Metadata = data
		case "AND":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AND"))
			data, err := ec.unmarshalOProductFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "OR":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("OR"))
			data, err := ec.unmarshalOProductFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "NOT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NOT"))
			data, err := ec.unmarshalOProductFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProductOrdering(ctx context.Context, obj any) (model.ProductOrdering, error) {
	var it model.ProductOrdering
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "metadata"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalO_OrderingTypes2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐOrderingTypes(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalO_OrderingTypes2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐOrderingTypes(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "metadata":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metadata"))
			data, err := ec.unmarshalO_OrderingTypes2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐOrderingTypes(ctx, v)
			if err != nil {
				return it, err
			}
			it.Metadata = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpecsFilterInput(ctx context.Context, obj any) (model.SpecsFilterInput, error) {
	var it model.SpecsFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"weight", "dimensions", "AND", "OR", "NOT"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalOFloatComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐFloatComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "dimensions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dimensions"))
			data, err := ec.unmarshalODimensionsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐDimensionsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dimensions = data
		case "AND":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AND"))
			data, err := ec.unmarshalOSpecsFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐSpecsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "OR":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("OR"))
			data, err := ec.unmarshalOSpecsFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐSpecsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "NOT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NOT"))
			data, err := ec.unmarshalOSpecsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐSpecsFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringComparator(ctx context.Context, obj any) (model1.StringComparator, error) {
	var it model1.StringComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "neq", "contains", "notContains", "like", "ilike", "suffix", "prefix", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "contains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contains"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Contains = data
		case "notContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notContains"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotContains = data
		case "like":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("like"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Like = data
		case "ilike":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ilike"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ilike = data
		case "suffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Suffix = data
		case "prefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Prefix = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStringListComparator(ctx context.Context, obj any) (model1.StringListComparator, error) {
	var it model1.StringListComparator
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"eq", "neq", "contains", "containedBy", "overlap", "isNull"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "neq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("neq"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Neq = data
		case "contains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contains"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Contains = data
		case "containedBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containedBy"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainedBy = data
		case "overlap":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("overlap"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Overlap = data
		case "isNull":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNull"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNull = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWarrantyInfoFilterInput(ctx context.Context, obj any) (model.WarrantyInfoFilterInput, error) {
	var it model.WarrantyInfoFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"years", "provider", "AND", "OR", "NOT"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "years":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("years"))
			data, err := ec.unmarshalOIntComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐIntComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Years = data
		case "provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalOStringComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐStringComparator(ctx, v)
			if err != nil {
				return it, err
			}
			it.Provider = data
		case "AND":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("AND"))
			data, err := ec.unmarshalOWarrantyInfoFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐWarrantyInfoFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "OR":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("OR"))
			data, err := ec.unmarshalOWarrantyInfoFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐWarrantyInfoFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "NOT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("NOT"))
			data, err := ec.unmarshalOWarrantyInfoFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐWarrantyInfoFilterInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var dimensionsImplementors = []string{"Dimensions"}

func (ec *executionContext) _Dimensions(ctx context.Context, sel ast.SelectionSet, obj *model.Dimensions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dimensionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dimensions")
		case "width":
			out.Values[i] = ec._Dimensions_width(ctx, field, obj)
		case "height":
			out.Values[i] = ec._Dimensions_height(ctx, field, obj)
		case "depth":
			out.Values[i] = ec._Dimensions_depth(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var productImplementors = []string{"Product"}

func (ec *executionContext) _Product(ctx context.Context, sel ast.SelectionSet, obj *model.Product) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, productImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Product")
		case "id":
			out.Values[i] = ec._Product_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Product_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attributes":
			out.Values[i] = ec._Product_attributes(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._Product_metadata(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var productAttributesImplementors = []string{"ProductAttributes"}

func (ec *executionContext) _ProductAttributes(ctx context.Context, sel ast.SelectionSet, obj *model.ProductAttributes) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, productAttributesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProductAttributes")
		case "color":
			out.Values[i] = ec._ProductAttributes_color(ctx, field, obj)
		case "size":
			out.Values[i] = ec._ProductAttributes_size(ctx, field, obj)
		case "tags":
			out.Values[i] = ec._ProductAttributes_tags(ctx, field, obj)
		case "details":
			out.Values[i] = ec._ProductAttributes_details(ctx, field, obj)
		case "specs":
			out.Values[i] = ec._ProductAttributes_specs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var productDetailsImplementors = []string{"ProductDetails"}

func (ec *executionContext) _ProductDetails(ctx context.Context, sel ast.SelectionSet, obj *model.ProductDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, productDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProductDetails")
		case "manufacturer":
			out.Values[i] = ec._ProductDetails_manufacturer(ctx, field, obj)
		case "model":
			out.Values[i] = ec._ProductDetails_model(ctx, field, obj)
		case "warranty":
			out.Values[i] = ec._ProductDetails_warranty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var productsAggregateImplementors = []string{"ProductsAggregate"}

func (ec *executionContext) _ProductsAggregate(ctx context.Context, sel ast.SelectionSet, obj *model.ProductsAggregate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, productsAggregateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProductsAggregate")
		case "group":
			out.Values[i] = ec._ProductsAggregate_group(ctx, field, obj)
		case "count":
			out.Values[i] = ec._ProductsAggregate_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "max":
			out.Values[i] = ec._ProductsAggregate_max(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "min":
			out.Values[i] = ec._ProductsAggregate_min(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "avg":
			out.Values[i] = ec._ProductsAggregate_avg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sum":
			out.Values[i] = ec._ProductsAggregate_sum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "products":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_products(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "_productsAggregate":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__productsAggregate(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var specsImplementors = []string{"Specs"}

func (ec *executionContext) _Specs(ctx context.Context, sel ast.SelectionSet, obj *model.Specs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, specsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Specs")
		case "weight":
			out.Values[i] = ec._Specs_weight(ctx, field, obj)
		case "dimensions":
			out.Values[i] = ec._Specs_dimensions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var warrantyInfoImplementors = []string{"WarrantyInfo"}

func (ec *executionContext) _WarrantyInfo(ctx context.Context, sel ast.SelectionSet, obj *model.WarrantyInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, warrantyInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WarrantyInfo")
		case "years":
			out.Values[i] = ec._WarrantyInfo_years(ctx, field, obj)
		case "provider":
			out.Values[i] = ec._WarrantyInfo_provider(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var _AggregateResultImplementors = []string{"_AggregateResult"}

func (ec *executionContext) __AggregateResult(ctx context.Context, sel ast.SelectionSet, obj *model1.AggregateResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _AggregateResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_AggregateResult")
		case "count":
			out.Values[i] = ec.__AggregateResult_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var _ProductAvgImplementors = []string{"_ProductAvg"}

func (ec *executionContext) __ProductAvg(ctx context.Context, sel ast.SelectionSet, obj *model.ProductAvg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ProductAvgImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_ProductAvg")
		case "id":
			out.Values[i] = ec.__ProductAvg_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var _ProductMaxImplementors = []string{"_ProductMax"}

func (ec *executionContext) __ProductMax(ctx context.Context, sel ast.SelectionSet, obj *model.ProductMax) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ProductMaxImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_ProductMax")
		case "id":
			out.Values[i] = ec.__ProductMax_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.__ProductMax_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var _ProductMinImplementors = []string{"_ProductMin"}

func (ec *executionContext) __ProductMin(ctx context.Context, sel ast.SelectionSet, obj *model.ProductMin) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ProductMinImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_ProductMin")
		case "id":
			out.Values[i] = ec.__ProductMin_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.__ProductMin_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var _ProductSumImplementors = []string{"_ProductSum"}

func (ec *executionContext) __ProductSum(ctx context.Context, sel ast.SelectionSet, obj *model.ProductSum) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, _ProductSumImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("_ProductSum")
		case "id":
			out.Values[i] = ec.__ProductSum_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMapPathCondition2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐMapPathCondition(ctx context.Context, v any) (*model.MapPathCondition, error) {
	res, err := ec.unmarshalInputMapPathCondition(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProductGroupBy2githubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductGroupBy(ctx context.Context, v any) (model.ProductGroupBy, error) {
	var res model.ProductGroupBy
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProductGroupBy2githubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductGroupBy(ctx context.Context, sel ast.SelectionSet, v model.ProductGroupBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProductsAggregate2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductsAggregateᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ProductsAggregate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProductsAggregate2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductsAggregate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProductsAggregate2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductsAggregate(ctx context.Context, sel ast.SelectionSet, v *model.ProductsAggregate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProductsAggregate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN_ProductAvg2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAvg(ctx context.Context, sel ast.SelectionSet, v *model.ProductAvg) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.__ProductAvg(ctx, sel, v)
}

func (ec *executionContext) marshalN_ProductMax2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductMax(ctx context.Context, sel ast.SelectionSet, v *model.ProductMax) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.__ProductMax(ctx, sel, v)
}

func (ec *executionContext) marshalN_ProductMin2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductMin(ctx context.Context, sel ast.SelectionSet, v *model.ProductMin) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.__ProductMin(ctx, sel, v)
}

func (ec *executionContext) marshalN_ProductSum2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductSum(ctx context.Context, sel ast.SelectionSet, v *model.ProductSum) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.__ProductSum(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			graphql.AddErrorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN_relationType2githubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐRelationType(ctx context.Context, v any) (model1.RelationType, error) {
	var res model1.RelationType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN_relationType2githubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐRelationType(ctx context.Context, sel ast.SelectionSet, v model1.RelationType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚕᚖbool(ctx context.Context, v any) ([]*bool, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*bool, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOBoolean2ᚖbool(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBoolean2ᚕᚖbool(ctx context.Context, sel ast.SelectionSet, v []*bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOBoolean2ᚖbool(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalODimensions2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐDimensions(ctx context.Context, sel ast.SelectionSet, v *model.Dimensions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Dimensions(ctx, sel, v)
}

func (ec *executionContext) unmarshalODimensionsFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐDimensionsFilterInput(ctx context.Context, v any) ([]*model.DimensionsFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.DimensionsFilterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalODimensionsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐDimensionsFilterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODimensionsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐDimensionsFilterInput(ctx context.Context, v any) (*model.DimensionsFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDimensionsFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2ᚕᚖfloat64(ctx context.Context, v any) ([]*float64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFloat2ᚖfloat64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFloat2ᚕᚖfloat64(ctx context.Context, sel ast.SelectionSet, v []*float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOFloat2ᚖfloat64(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFloatComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐFloatComparator(ctx context.Context, v any) (*model1.FloatComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFloatComparator(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚕᚖint(ctx context.Context, v any) ([]*int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOInt2ᚖint(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕᚖint(ctx context.Context, sel ast.SelectionSet, v []*int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2ᚖint(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOIntComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐIntComparator(ctx context.Context, v any) (*model1.IntComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIntComparator(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v any) (map[string]any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOMapComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐMapComparator(ctx context.Context, v any) (*model.MapComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMapComparator(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMapPathCondition2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐMapPathConditionᚄ(ctx context.Context, v any) ([]*model.MapPathCondition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.MapPathCondition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMapPathCondition2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐMapPathCondition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProduct2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProduct(ctx context.Context, sel ast.SelectionSet, v []*model.Product) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProduct2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProduct(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOProduct2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProduct(ctx context.Context, sel ast.SelectionSet, v *model.Product) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Product(ctx, sel, v)
}

func (ec *executionContext) marshalOProductAttributes2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAttributes(ctx context.Context, sel ast.SelectionSet, v *model.ProductAttributes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProductAttributes(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProductAttributesFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAttributesFilterInput(ctx context.Context, v any) ([]*model.ProductAttributesFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.ProductAttributesFilterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOProductAttributesFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAttributesFilterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProductAttributesFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductAttributesFilterInput(ctx context.Context, v any) (*model.ProductAttributesFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProductAttributesFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProductDetails2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductDetails(ctx context.Context, sel ast.SelectionSet, v *model.ProductDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProductDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProductDetailsFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductDetailsFilterInput(ctx context.Context, v any) ([]*model.ProductDetailsFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.ProductDetailsFilterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOProductDetailsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductDetailsFilterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProductDetailsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductDetailsFilterInput(ctx context.Context, v any) (*model.ProductDetailsFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProductDetailsFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProductFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductFilterInput(ctx context.Context, v any) ([]*model.ProductFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.ProductFilterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOProductFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductFilterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProductFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductFilterInput(ctx context.Context, v any) (*model.ProductFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProductFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProductGroupBy2ᚕgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductGroupByᚄ(ctx context.Context, v any) ([]model.ProductGroupBy, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.ProductGroupBy, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProductGroupBy2githubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductGroupBy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProductGroupBy2ᚕgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductGroupByᚄ(ctx context.Context, sel ast.SelectionSet, v []model.ProductGroupBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProductGroupBy2githubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductGroupBy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProductOrdering2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductOrdering(ctx context.Context, v any) ([]*model.ProductOrdering, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.ProductOrdering, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOProductOrdering2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductOrdering(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOProductOrdering2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐProductOrdering(ctx context.Context, v any) (*model.ProductOrdering, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProductOrdering(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSpecs2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐSpecs(ctx context.Context, sel ast.SelectionSet, v *model.Specs) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Specs(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSpecsFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐSpecsFilterInput(ctx context.Context, v any) ([]*model.SpecsFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.SpecsFilterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOSpecsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐSpecsFilterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSpecsFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐSpecsFilterInput(ctx context.Context, v any) (*model.SpecsFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSpecsFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v any) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStringComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐStringComparator(ctx context.Context, v any) (*model1.StringComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStringComparator(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOStringListComparator2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐStringListComparator(ctx context.Context, v any) (*model1.StringListComparator, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStringListComparator(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWarrantyInfo2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐWarrantyInfo(ctx context.Context, sel ast.SelectionSet, v *model.WarrantyInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WarrantyInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWarrantyInfoFilterInput2ᚕᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐWarrantyInfoFilterInput(ctx context.Context, v any) ([]*model.WarrantyInfoFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.WarrantyInfoFilterInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOWarrantyInfoFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐWarrantyInfoFilterInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWarrantyInfoFilterInput2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋjsonᚋgraphᚋmodelᚐWarrantyInfoFilterInput(ctx context.Context, v any) (*model.WarrantyInfoFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWarrantyInfoFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalO_OrderingTypes2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐOrderingTypes(ctx context.Context, v any) (*model1.OrderingTypes, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model1.OrderingTypes)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO_OrderingTypes2ᚖgithubᚗcomᚋroneliᚋfastgqlᚋexamplesᚋinterfaceᚋgraphᚋmodelᚐOrderingTypes(ctx context.Context, sel ast.SelectionSet, v *model1.OrderingTypes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
