// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Animal interface {
	GetID() int
	GetName() string
	GetType() string
}

type AnimalFilterInput struct {
	ID   *IntComparator    `json:"id,omitempty"`
	Name *StringComparator `json:"name,omitempty"`
	Type *StringComparator `json:"type,omitempty"`
	Cat  *CatFilterInput   `json:"Cat,omitempty"`
	Dog  *DogFilterInput   `json:"Dog,omitempty"`
	// Logical AND of FilterInput
	And []*AnimalFilterInput `json:"AND,omitempty"`
	// Logical OR of FilterInput
	Or []*AnimalFilterInput `json:"OR,omitempty"`
	// Logical NOT of FilterInput
	Not *AnimalFilterInput `json:"NOT,omitempty"`
}

// max aggregator for Animal
type AnimalMin struct {
	// Compute the maxiumum for id
	ID string `json:"id"`
	// Compute the maxiumum for name
	Name string `json:"name"`
	// Compute the maxiumum for type
	Type string `json:"type"`
}

// Ordering for Animal
type AnimalOrdering struct {
	// Order Animal by id
	ID *OrderingTypes `json:"id,omitempty"`
	// Order Animal by name
	Name *OrderingTypes `json:"name,omitempty"`
	// Order Animal by type
	Type *OrderingTypes `json:"type,omitempty"`
}

// Aggregate Animal
type AnimalsAggregate struct {
	// Count results
	Count int `json:"count"`
	// Computes the maximum of the non-null input values.
	Max *AnimalMin `json:"max,omitempty"`
	// Computes the minimum of the non-null input values.
	Min *AnimalMin `json:"min,omitempty"`
}

type BooleanComparator struct {
	Eq     *bool `json:"eq,omitempty"`
	Neq    *bool `json:"neq,omitempty"`
	IsNull *bool `json:"isNull,omitempty"`
}

type BooleanListComparator struct {
	Eq        []*bool `json:"eq,omitempty"`
	Neq       []*bool `json:"neq,omitempty"`
	Contains  []*bool `json:"contains,omitempty"`
	Contained []*bool `json:"contained,omitempty"`
	Overlap   []*bool `json:"overlap,omitempty"`
	IsNull    *bool   `json:"isNull,omitempty"`
}

type Cat struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Type  string `json:"type"`
	Color string `json:"color"`
}

func (Cat) IsAnimal()            {}
func (this Cat) GetID() int      { return this.ID }
func (this Cat) GetName() string { return this.Name }
func (this Cat) GetType() string { return this.Type }

type CatFilterInput struct {
	ID    *IntComparator    `json:"id,omitempty"`
	Name  *StringComparator `json:"name,omitempty"`
	Type  *StringComparator `json:"type,omitempty"`
	Color *StringComparator `json:"color,omitempty"`
	// Logical AND of FilterInput
	And []*CatFilterInput `json:"AND,omitempty"`
	// Logical OR of FilterInput
	Or []*CatFilterInput `json:"OR,omitempty"`
	// Logical NOT of FilterInput
	Not *CatFilterInput `json:"NOT,omitempty"`
}

// Aggregate Category
type CategoriesAggregate struct {
	// Count results
	Count int `json:"count"`
	// Computes the maximum of the non-null input values.
	Max *CategoryMin `json:"max,omitempty"`
	// Computes the minimum of the non-null input values.
	Min *CategoryMin `json:"min,omitempty"`
}

type Category struct {
	ID   int     `json:"id"`
	Name *string `json:"name,omitempty"`
}

type CategoryFilterInput struct {
	ID   *IntComparator    `json:"id,omitempty"`
	Name *StringComparator `json:"name,omitempty"`
	// Logical AND of FilterInput
	And []*CategoryFilterInput `json:"AND,omitempty"`
	// Logical OR of FilterInput
	Or []*CategoryFilterInput `json:"OR,omitempty"`
	// Logical NOT of FilterInput
	Not *CategoryFilterInput `json:"NOT,omitempty"`
}

// max aggregator for Category
type CategoryMin struct {
	// Compute the maxiumum for id
	ID int `json:"id"`
	// Compute the maxiumum for name
	Name string `json:"name"`
}

// Ordering for Category
type CategoryOrdering struct {
	// Order Category by id
	ID *OrderingTypes `json:"id,omitempty"`
	// Order Category by name
	Name *OrderingTypes `json:"name,omitempty"`
}

type Dog struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Type  string `json:"type"`
	Breed string `json:"breed"`
}

func (Dog) IsAnimal()            {}
func (this Dog) GetID() int      { return this.ID }
func (this Dog) GetName() string { return this.Name }
func (this Dog) GetType() string { return this.Type }

type DogFilterInput struct {
	ID    *IntComparator    `json:"id,omitempty"`
	Name  *StringComparator `json:"name,omitempty"`
	Type  *StringComparator `json:"type,omitempty"`
	Breed *StringComparator `json:"breed,omitempty"`
	// Logical AND of FilterInput
	And []*DogFilterInput `json:"AND,omitempty"`
	// Logical OR of FilterInput
	Or []*DogFilterInput `json:"OR,omitempty"`
	// Logical NOT of FilterInput
	Not *DogFilterInput `json:"NOT,omitempty"`
}

type FloatComparator struct {
	Eq     *float64 `json:"eq,omitempty"`
	Neq    *float64 `json:"neq,omitempty"`
	Gt     *float64 `json:"gt,omitempty"`
	Gte    *float64 `json:"gte,omitempty"`
	Lt     *float64 `json:"lt,omitempty"`
	Lte    *float64 `json:"lte,omitempty"`
	IsNull *bool    `json:"isNull,omitempty"`
}

type FloatListComparator struct {
	Eq        []*float64 `json:"eq,omitempty"`
	Neq       []*float64 `json:"neq,omitempty"`
	Contains  []*float64 `json:"contains,omitempty"`
	Contained []*float64 `json:"contained,omitempty"`
	Overlap   []*float64 `json:"overlap,omitempty"`
	IsNull    *bool      `json:"isNull,omitempty"`
}

type IntComparator struct {
	Eq     *int  `json:"eq,omitempty"`
	Neq    *int  `json:"neq,omitempty"`
	Gt     *int  `json:"gt,omitempty"`
	Gte    *int  `json:"gte,omitempty"`
	Lt     *int  `json:"lt,omitempty"`
	Lte    *int  `json:"lte,omitempty"`
	IsNull *bool `json:"isNull,omitempty"`
}

type IntListComparator struct {
	Eq        []*int `json:"eq,omitempty"`
	Neq       []*int `json:"neq,omitempty"`
	Contains  []*int `json:"contains,omitempty"`
	Contained []*int `json:"contained,omitempty"`
	Overlap   []*int `json:"overlap,omitempty"`
	IsNull    *bool  `json:"isNull,omitempty"`
}

type Post struct {
	ID         int         `json:"id"`
	Name       *string     `json:"name,omitempty"`
	Categories []*Category `json:"categories,omitempty"`
	UserID     *int        `json:"user_id,omitempty"`
	User       *User       `json:"user,omitempty"`
}

type PostFilterInput struct {
	ID         *IntComparator       `json:"id,omitempty"`
	Name       *StringComparator    `json:"name,omitempty"`
	Categories *CategoryFilterInput `json:"categories,omitempty"`
	UserID     *IntComparator       `json:"user_id,omitempty"`
	// Logical AND of FilterInput
	And []*PostFilterInput `json:"AND,omitempty"`
	// Logical OR of FilterInput
	Or []*PostFilterInput `json:"OR,omitempty"`
	// Logical NOT of FilterInput
	Not *PostFilterInput `json:"NOT,omitempty"`
}

// max aggregator for Post
type PostMin struct {
	// Compute the maxiumum for id
	ID int `json:"id"`
	// Compute the maxiumum for name
	Name string `json:"name"`
	// Compute the maxiumum for user_id
	UserID int `json:"user_id"`
}

// Ordering for Post
type PostOrdering struct {
	// Order Post by id
	ID *OrderingTypes `json:"id,omitempty"`
	// Order Post by name
	Name *OrderingTypes `json:"name,omitempty"`
	// Order Post by user_id
	UserID *OrderingTypes `json:"user_id,omitempty"`
}

// Aggregate Post
type PostsAggregate struct {
	// Count results
	Count int `json:"count"`
	// Computes the maximum of the non-null input values.
	Max *PostMin `json:"max,omitempty"`
	// Computes the minimum of the non-null input values.
	Min *PostMin `json:"min,omitempty"`
}

type StringComparator struct {
	Eq          *string   `json:"eq,omitempty"`
	Neq         *string   `json:"neq,omitempty"`
	Contains    []*string `json:"contains,omitempty"`
	NotContains []*string `json:"notContains,omitempty"`
	Like        *string   `json:"like,omitempty"`
	Ilike       *string   `json:"ilike,omitempty"`
	Suffix      *string   `json:"suffix,omitempty"`
	Prefix      *string   `json:"prefix,omitempty"`
	IsNull      *bool     `json:"isNull,omitempty"`
}

type StringListComparator struct {
	Eq          []*string `json:"eq,omitempty"`
	Neq         []*string `json:"neq,omitempty"`
	Contains    []*string `json:"contains,omitempty"`
	ContainedBy []*string `json:"containedBy,omitempty"`
	Overlap     []*string `json:"overlap,omitempty"`
	IsNull      *bool     `json:"isNull,omitempty"`
}

type User struct {
	ID    int     `json:"id"`
	Name  string  `json:"name"`
	Posts []*Post `json:"posts,omitempty"`
}

// max aggregator for User
type UserMin struct {
	// Compute the maxiumum for id
	ID int `json:"id"`
	// Compute the maxiumum for name
	Name string `json:"name"`
}

// Ordering for User
type UserOrdering struct {
	// Order User by id
	ID *OrderingTypes `json:"id,omitempty"`
	// Order User by name
	Name *OrderingTypes `json:"name,omitempty"`
}

// Aggregate User
type UsersAggregate struct {
	// Count results
	Count int `json:"count"`
	// Computes the maximum of the non-null input values.
	Max *UserMin `json:"max,omitempty"`
	// Computes the minimum of the non-null input values.
	Min *UserMin `json:"min,omitempty"`
}

type AggregateResult struct {
	Count int `json:"count"`
}

type OrderingTypes string

const (
	OrderingTypesAsc           OrderingTypes = "ASC"
	OrderingTypesDesc          OrderingTypes = "DESC"
	OrderingTypesAscNullFirst  OrderingTypes = "ASC_NULL_FIRST"
	OrderingTypesDescNullFirst OrderingTypes = "DESC_NULL_FIRST"
	OrderingTypesAscNullLast   OrderingTypes = "ASC_NULL_LAST"
	OrderingTypesDescNullLast  OrderingTypes = "DESC_NULL_LAST"
)

var AllOrderingTypes = []OrderingTypes{
	OrderingTypesAsc,
	OrderingTypesDesc,
	OrderingTypesAscNullFirst,
	OrderingTypesDescNullFirst,
	OrderingTypesAscNullLast,
	OrderingTypesDescNullLast,
}

func (e OrderingTypes) IsValid() bool {
	switch e {
	case OrderingTypesAsc, OrderingTypesDesc, OrderingTypesAscNullFirst, OrderingTypesDescNullFirst, OrderingTypesAscNullLast, OrderingTypesDescNullLast:
		return true
	}
	return false
}

func (e OrderingTypes) String() string {
	return string(e)
}

func (e *OrderingTypes) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderingTypes(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid _OrderingTypes", str)
	}
	return nil
}

func (e OrderingTypes) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RelationType string

const (
	RelationTypeOneToOne   RelationType = "ONE_TO_ONE"
	RelationTypeOneToMany  RelationType = "ONE_TO_MANY"
	RelationTypeManyToMany RelationType = "MANY_TO_MANY"
)

var AllRelationType = []RelationType{
	RelationTypeOneToOne,
	RelationTypeOneToMany,
	RelationTypeManyToMany,
}

func (e RelationType) IsValid() bool {
	switch e {
	case RelationTypeOneToOne, RelationTypeOneToMany, RelationTypeManyToMany:
		return true
	}
	return false
}

func (e RelationType) String() string {
	return string(e)
}

func (e *RelationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RelationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid _relationType", str)
	}
	return nil
}

func (e RelationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
