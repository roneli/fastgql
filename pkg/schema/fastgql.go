package schema

import (
	_ "embed"
	"fmt"
	"log"

	"github.com/roneli/fastgql/pkg/schema/augmenters"
	"github.com/roneli/fastgql/pkg/schema/gql"
	"github.com/roneli/fastgql/pkg/schema/plugin"
	"github.com/roneli/fastgql/pkg/schema/plugin/resolvergen"
	"github.com/roneli/fastgql/pkg/schema/plugin/servergen"

	"github.com/99designs/gqlgen/api"
	"github.com/99designs/gqlgen/codegen/config"
	"github.com/99designs/gqlgen/plugin/modelgen"
	"github.com/vektah/gqlparser/v2/ast"
)

var (
	//go:embed fastgql.graphql
	FastGQLSchema     string
	FastGQLDirectives = []string{"table", "generate", "relation", "generateFilterInput", "generateMutations"}
	baseDialect       = "postgres"
)

// FastGqlPlugin augments and extends the original schema
type FastGqlPlugin struct{}

func (f FastGqlPlugin) Name() string {
	return "fastGQLPlugin"
}

func (f FastGqlPlugin) MutateConfig(c *config.Config) error {
	// Skip runtime checks for all FastGQL directives as they only used on the server side schema
	for _, d := range FastGQLDirectives {
		c.Directives[d] = config.DirectiveConfig{SkipRuntime: true}
	}
	if err := f.MarkResolvers(c); err != nil {
		return fmt.Errorf("failed to mark resolvers to generate: %w", err)
	}
	return nil
}

// MarkResolvers goes over all types and marks any fields that resolver should be created for, theses resolvers
// are generated by the fastgql resolvergen.Plugin
func (f FastGqlPlugin) MarkResolvers(c *config.Config) error {

	for _, schemaType := range c.Schema.Types {
		// skip common types that are not interesting for resolver creation
		if schemaType == c.Schema.Query || schemaType == c.Schema.Mutation || schemaType == c.Schema.Subscription || schemaType.IsLeafType() {
			continue
		}

		// check if type has a "generate" directive, we will force all its fields to be resolved.
		if rg := schemaType.Directives.ForName("generate"); rg != nil {
			log.Printf("Generating resolvers for all fields under %s\n", schemaType.Name)
			for _, f := range schemaType.Fields {
				if c.Models[schemaType.Name].Fields == nil {
					c.Models[schemaType.Name] = config.TypeMapEntry{
						Model:  c.Models[schemaType.Name].Model,
						Fields: map[string]config.TypeMapField{},
					}
				}
				log.Printf("Settting create resolver for %s.%s \n", schemaType.Name, f.Name)
				c.Models[schemaType.Name].Fields[f.Name] = config.TypeMapField{
					FieldName: f.Name,
					Resolver:  true,
				}
			}
		}

		parentDialect := baseDialect
		value := gql.GetDirectiveValue(schemaType.Directives.ForName("table"), "dialect")
		if value != nil {
			parentDialect = value.(string)
		}

		for _, f := range schemaType.Fields {
			fieldType := c.Schema.Types[gql.GetType(f.Type).NamedType]
			if !fieldType.IsCompositeType() {
				continue
			}
			value := gql.GetDirectiveValue(fieldType.Directives.ForName("table"), "dialect")
			if value == nil {
				continue
			}
			fmt.Println("dialect")
			if value == parentDialect {
				continue
			}
			if c.Models[schemaType.Name].Fields == nil {
				c.Models[schemaType.Name] = config.TypeMapEntry{
					Model:  c.Models[schemaType.Name].Model,
					Fields: map[string]config.TypeMapField{},
				}
			}
			c.Models[schemaType.Name].Fields[f.Name] = config.TypeMapField{
				FieldName: f.Name,
				Resolver:  true,
			}
		}
	}
	return nil
}

// TODO: make this configurable
func (f FastGqlPlugin) CreateAugmented(schema *ast.Schema) []*ast.Source {
	_ = augmenters.Pagination{}.Augment(schema)
	_ = augmenters.Ordering{}.Augment(schema)
	_ = augmenters.Aggregation{}.Augment(schema)
	_ = augmenters.FilterInput{}.Augment(schema)
	_ = augmenters.FilterArguments{}.Augment(schema)
	_ = augmenters.Mutations{}.Augment(schema)
	return FormatSchema(schema)
}

func Generate(configPath string, generateServer bool, sources ...*ast.Source) error {
	cfg, err := config.LoadConfig(configPath)
	if err != nil {
		return err
	}
	if sources != nil {
		cfg.Sources = append(cfg.Sources, sources...)
	}
	err = cfg.LoadSchema()
	if err != nil {
		return err
	}
	fgqlPlugin := FastGqlPlugin{}
	srcs := fgqlPlugin.CreateAugmented(cfg.Schema)

	// Load config again
	cfg, err = config.LoadConfig(configPath)
	if err != nil {
		return err
	}
	cfg.Sources = srcs

	// Attaching the mutation function onto modelgen plugin
	modelgenPlugin := modelgen.Plugin{
		MutateHook: plugin.MutateHook,
	}

	// skip validation for now, as after code generation we need to mod tidy again
	cfg.SkipValidation = true

	if generateServer {
		err = api.Generate(cfg, api.NoPlugins(), api.AddPlugin(&modelgenPlugin), api.AddPlugin(resolvergen.New()),
			api.AddPlugin(fgqlPlugin), api.AddPlugin(servergen.New("server.go")))
	} else {
		err = api.Generate(cfg, api.NoPlugins(), api.AddPlugin(&modelgenPlugin), api.AddPlugin(resolvergen.New()), api.AddPlugin(fgqlPlugin))
	}

	if err != nil {
		return err
	}
	return nil
}
