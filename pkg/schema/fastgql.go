package schema

import (
	_ "embed"
	"fmt"
	"log"

	"github.com/99designs/gqlgen/codegen/config"
	"github.com/roneli/fastgql/pkg/schema/augmenters"
	"github.com/roneli/fastgql/pkg/schema/gql"
	"github.com/vektah/gqlparser/v2/ast"
)

var (
	//go:embed fastgql.graphql
	FastGQLSchema     string
	FastGQLDirectives = []string{"table", "generate", "relation", "generateFilterInput", "skipGenerate", "generateMutations", "relation"}
	baseDialect       = "postgres"
	defaultAugmenters = []augmenters.Augmenter{
		augmenters.Pagination{},
		augmenters.Ordering{},
		augmenters.Aggregation{},
		augmenters.FilterInput{},
		augmenters.FilterArguments{},
		augmenters.Mutations{},
	}
)

// FastGqlPlugin augments and extends the original schema
type FastGqlPlugin struct{}

func NewFastGQLPlugin() FastGqlPlugin {
	return FastGqlPlugin{}
}

func (f FastGqlPlugin) Name() string {
	return "fastGQLPlugin"
}

func (f FastGqlPlugin) MutateConfig(c *config.Config) error {
	// Skip runtime checks for all FastGQL directives as they only used on the server side schema
	for _, d := range FastGQLDirectives {
		c.Directives[d] = config.DirectiveConfig{SkipRuntime: true}
	}
	if err := f.MarkResolvers(c); err != nil {
		return fmt.Errorf("failed to mark resolvers to generate: %w", err)
	}
	return nil
}

// MarkResolvers goes over all types and marks any fields that resolver should be created for, these resolvers
// are generated by the fastgql resolvergen.Plugin
func (f FastGqlPlugin) MarkResolvers(c *config.Config) error {
	for _, schemaType := range c.Schema.Types {
		// skip common types that are not interesting for resolver creation
		if schemaType == c.Schema.Query || schemaType == c.Schema.Mutation || schemaType == c.Schema.Subscription || schemaType.IsLeafType() {
			continue
		}
		// check if type has a "generate" directive, we will force all its fields to be resolved.
		if rg := schemaType.Directives.ForName("generate"); rg != nil {
			log.Printf("Generating resolvers for all fields under %s\n", schemaType.Name)
			for _, f := range schemaType.Fields {
				if c.Models[schemaType.Name].Fields == nil {
					c.Models[schemaType.Name] = config.TypeMapEntry{
						Model:  c.Models[schemaType.Name].Model,
						Fields: map[string]config.TypeMapField{},
					}
				}
				log.Printf("Setting create resolver for %s.%s \n", schemaType.Name, f.Name)
				c.Models[schemaType.Name].Fields[f.Name] = config.TypeMapField{
					FieldName: f.Name,
					Resolver:  true,
				}
			}
		}

		parentDialect := baseDialect
		value := gql.GetDirectiveValue(schemaType.Directives.ForName("table"), "dialect")
		if value != nil {
			parentDialect = value.(string)
		}

		for _, f := range schemaType.Fields {
			fieldType := c.Schema.Types[gql.GetType(f.Type).NamedType]
			if !fieldType.IsCompositeType() {
				continue
			}
			value := gql.GetDirectiveValue(fieldType.Directives.ForName("table"), "dialect")
			if value == nil {
				continue
			}
			fmt.Println("dialect")
			if value == parentDialect {
				continue
			}
			if c.Models[schemaType.Name].Fields == nil {
				c.Models[schemaType.Name] = config.TypeMapEntry{
					Model:  c.Models[schemaType.Name].Model,
					Fields: map[string]config.TypeMapField{},
				}
			}
			c.Models[schemaType.Name].Fields[f.Name] = config.TypeMapField{
				FieldName: f.Name,
				Resolver:  true,
			}
		}
	}
	return nil
}

// CreateAugmented augments *ast.Schema returning []*ast.Source files that are augmented with filters, mutations etc'
// so gqlgen can generate an augmented fastGQL server
func (f FastGqlPlugin) CreateAugmented(schema *ast.Schema, augmenters ...augmenters.Augmenter) ([]*ast.Source, error) {
	if len(augmenters) == 0 {
		augmenters = defaultAugmenters
	}
	for _, a := range augmenters {
		if err := a.Augment(schema); err != nil {
			return nil, fmt.Errorf("augmenter %s failed: %w", a.Name(), err)
		}
	}
	// Format augmented schema to *.graphql files
	return FormatSchema("graph", schema), nil
}
